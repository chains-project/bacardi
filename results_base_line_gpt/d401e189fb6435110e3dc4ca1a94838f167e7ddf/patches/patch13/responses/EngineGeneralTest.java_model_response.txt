```java
/*
 * Copyright 2014 Feedzai
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.feedzai.commons.sql.abstraction.engine.impl.abs;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import com.feedzai.commons.sql.abstraction.ddl.AlterColumn;
import com.feedzai.commons.sql.abstraction.ddl.DbColumn;
import com.feedzai.commons.sql.abstraction.ddl.DbColumnConstraint;
import com.feedzai.commons.sql.abstraction.ddl.DbColumnType;
import com.feedzai.commons.sql.abstraction.ddl.DbEntity;
import com.feedzai.commons.sql.abstraction.ddl.Rename;
import com.feedzai.commons.sql.abstraction.dml.Expression;
import com.feedzai.commons.sql.abstraction.dml.K;
import com.feedzai.commons.sql.abstraction.dml.Query;
import com.feedzai.commons.sql.abstraction.dml.Truncate;
import com.feedzai.commons.sql.abstraction.dml.Update;
import com.feedzai.commons.sql.abstraction.dml.Values;
import com.feedzai.commons.sql.abstraction.dml.With;
import com.feedzai.commons.sql.abstraction.dml.dialect.Dialect;
import com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder;
import com.feedzai.commons.sql.abstraction.dml.result.ResultColumn;
import com.feedzai.commons.sql.abstraction.dml.result.ResultIterator;
import com.feedzai.commons.sql.abstraction.engine.AbstractDatabaseEngine;
import com.feedzai.commons.sql.abstraction.engine.ConnectionResetException;
import com.feedzai.commons.sql.abstraction.engine.DatabaseEngine;
import com.feedzai.commons.sql.abstraction.engine.DatabaseEngineException;
import com.feedzai.commons.sql.abstraction.engine.DatabaseEngineRuntimeException;
import com.feedzai.commons.sql.abstraction.exceptions.DatabaseEngineUniqueConstraintViolationException;
import com.feedzai.commons.sql.abstraction.engine.DatabaseFactory;
import com.feedzai.commons.sql.abstraction.engine.DatabaseFactoryException;
import com.feedzai.commons.sql.abstraction.engine.MappedEntity;
import com.feedzai.commons.sql.abstraction.engine.NameAlreadyExistsException;
import com.feedzai.commons.sql.abstraction.engine.OperationNotSupportedRuntimeException;
import com.feedzai.commons.sql.abstraction.engine.impl.cockroach.SkipTestCockroachDB;
import com.feedzai.commons.sql.abstraction.engine.testconfig.BlobTest;
import com.feedzai.commons.sql.abstraction.engine.testconfig.DatabaseConfiguration;
import com.feedzai.commons.sql.abstraction.engine.testconfig.DatabaseTestUtil;
import com.feedzai.commons.sql.abstraction.entry.EntityEntry;
import com.google.common.collect.ImmutableSet;
import java.sql.SQLException;
import mockit.Expectations;
import mockit.Invocation;
import mockit.Mock;
import mockit.MockUp;
import mockit.Verifications;
import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.experimental.categories.Category;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayOutputStream;
import java.io.ObjectOutputStream;
import java.sql.Connection;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static com.feedzai.commons.sql.abstraction.ddl.DbColumnConstraint.NOT_NULL;
import static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.BLOB;
import static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.BOOLEAN;
import static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.CLOB;
import static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.DOUBLE;
import static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.INT;
import static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.LONG;
import static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.STRING;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.L;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.all;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.avg;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.between;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.caseWhen;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.cast;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.ceiling;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.coalesce;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.column;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.concat;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.count;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.createView;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.dbColumn;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.dbEntity;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.dbFk;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.delete;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.div;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.dropPK;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.entry;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.eq;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.f;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.floor;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.in;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.k;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.like;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.lit;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.lower;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.max;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.min;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.mod;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.neq;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.notBetween;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.notIn;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.or;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.select;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.stddev;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.stringAgg;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.sum;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.table;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.udf;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.union;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.update;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.upper;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.values;
import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.with;
import static com.feedzai.commons.sql.abstraction.engine.EngineTestUtils.buildEntity;
import static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.ENGINE;
import static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.JDBC;
import static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.PASSWORD;
import static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.SCHEMA_POLICY;
import static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.USERNAME;
import static com.feedzai.commons.sql.abstraction.util.StringUtils.quotize;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatCode;
import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

/**
 * @author Rui Vilao (rui.vilao@feedzai.com)
 * @since 2.0.0
 */
@RunWith(Parameterized.class)
public class EngineGeneralTest {


    private static final double DELTA = 1e-7;

    protected DatabaseEngine engine;
    protected Properties properties;

    @Parameterized.Parameters
    public static Collection<DatabaseConfiguration> data() throws Exception {
        return DatabaseTestUtil.loadConfigurations();
    }

    @Parameterized.Parameter
    public DatabaseConfiguration config;

    @BeforeClass
    public static void initStatic() {
        ((Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)).setLevel(Level.TRACE);
    }

    @Before
    public void init() throws DatabaseFactoryException {
        properties = new Properties() {
            {
                setProperty(JDBC, config.jdbc);
                setProperty(USERNAME, config.username);
                setProperty(PASSWORD, config.password);
                setProperty(ENGINE, config.engine);
                setProperty(SCHEMA_POLICY, "drop-create");
            }
        };

        engine = DatabaseFactory.getConnection(properties);
    }

    @After
    public void cleanup() {
        engine.close();
    }

    @Test
    public void createEntityTest() throws DatabaseEngineException {

        DbEntity entity = dbEntity()
                .name("TEST")
                .addColumn("COL1", INT)
                .addColumn("COL2", BOOLEAN)
                .addColumn("COL3", DOUBLE)
                .addColumn("COL4", LONG)
                .addColumn("COL5", STRING)
                .pkFields("COL1")
                .build();

        engine.addEntity(entity);
    }

    @Test
    public void createEntityWithTwoColumnsBeingPKTest() throws DatabaseEngineException {

        DbEntity entity = dbEntity()
                .name("TEST")
                .addColumn("COL1", INT)
                .addColumn("COL2", BOOLEAN)
                .addColumn("COL3", DOUBLE)
                .addColumn("COL4", LONG)
                .addColumn("COL5", STRING)
                .pkFields("COL1", "COL3")
                .build();

        engine.addEntity(entity);
    }

    @Test(expected = DatabaseEngineException.class)
    public void createEntityAlreadyExistsTest() throws DatabaseEngineException {
        DbEntity entity = dbEntity()
                .name("TEST")
                .addColumn("COL1", INT)
                .addColumn("COL2", BOOLEAN)
                .addColumn("COL3", DOUBLE)
                .addColumn("COL4", LONG)
                .addColumn("COL5", STRING)
                .pkFields("COL1", "COL3")
                .build();

        engine.addEntity(entity);

        try {
            engine.addEntity(entity);
        } catch (final DatabaseEngineException e) {
            assertEquals("", "Entity 'TEST' is already defined", e.getMessage());
            throw e;
        }
    }

    @Test
    public void createUniqueIndexTest() throws DatabaseEngineException {
        DbEntity entity = dbEntity()
                .name("TEST")
                .addColumn("COL1", INT)
                .addColumn("COL2", BOOLEAN)
                .addColumn("COL3", DOUBLE)
                .addColumn("COL4", LONG)
                .addColumn("COL5", STRING)
                .pkFields("COL1", "COL3")
                .addIndex(true, "COL4")
                .build();

        engine.addEntity(entity);
    }

    @Test
    public void createIndexWithTwoColumnsTest() throws DatabaseEngineException {
        DbEntity entity = dbEntity()
                .name("TEST")
                .addColumn("COL1", INT)
                .addColumn("COL2", BOOLEAN)
                .addColumn("COL3", DOUBLE)
                .addColumn("COL4", LONG)
                .addColumn("COL5", STRING)
                .pkFields("COL1", "COL3")
                .addIndex("COL4", "COL3")
                .build();

        engine.addEntity(entity);
    }

    @Test
    public void createTwoIndexesTest() throws DatabaseEngineException {
        DbEntity entity = dbEntity()
                .name("TEST")
                .addColumn("COL1", INT)
                .addColumn("COL2", BOOLEAN)
                .addColumn("COL3", DOUBLE)
                .addColumn("COL4", LONG)
                .addColumn("COL5", STRING)
                .pkFields("COL1", "COL3")
                .addIndex("COL4")
                .addIndex("COL3")
                .build();

        engine.addEntity(entity);
    }

    @Test
    public void createEntityWithTheSameNameButLowerCasedTest() throws DatabaseEngineException {
        DbEntity entity = dbEntity()
                .name("TEST")
                .addColumn("COL1", INT)
                .addColumn("COL2", BOOLEAN)
                .addColumn("COL3", DOUBLE)
                .addColumn("COL4", LONG)
                .addColumn("COL5", STRING)
                .pkFields("COL1", "COL3")
                .build();

        engine.addEntity(entity);

        DbEntity entity2 = dbEntity()
                .name("test")
                .addColumn("COL1", INT)
                .addColumn("COL2", BOOLEAN)
                .addColumn("COL3", DOUBLE)
                .addColumn("COL4", LONG)
                .addColumn("COL5", STRING)
                .pkFields("COL1", "COL3")
                .build();

        engine.addEntity(entity2);

    }

    @Test
    public void createEntityWithSequencesTest() throws DatabaseEngineException {

        DbEntity entity = dbEntity()
                .name("TEST")
                .addColumn("COL1", INT, true)
                .addColumn("COL2", BOOLEAN)
                .addColumn("COL3", DOUBLE)
                .addColumn("COL4", LONG)
                .addColumn("COL5", STRING)
                .pkFields("COL1")
                .build();

        engine.addEntity(entity);
    }

    @Test
    public void createEntityWithIndexesTest() throws DatabaseEngineException {

        DbEntity entity = dbEntity()
                .name("TEST")
                .addColumn("COL1", INT, true)
                .addColumn("COL2", BOOLEAN)
                .addColumn("COL3", DOUBLE)
                .addColumn("COL4", LONG)
                .addColumn("COL5", STRING)
                .addIndex("COL4")
                .pkFields("COL1")
                .build();

        engine.addEntity(entity);
    }

    @Test
    public void insertWithControlledTransactionTest() throws Exception {
        create5ColumnsEntity();

        EntityEntry entry = entry().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS").build();

        engine.beginTransaction();

        try {

            engine.persist("TEST", entry);
            engine.commit();
        } finally {
            if (engine.isTransactionActive()) {
                engine.rollback();
            }
        }

        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")));

        assertTrue("COL1 exists", query.get(0).containsKey("COL1"));
        assertEquals("COL1 ok?", 2, (int) query.get(0).get("COL1").toInt());

        assertTrue("COL2 exists", query.get(0).containsKey("COL2"));
        assertFalse("COL2 ok?", query.get(0).get("COL2").toBoolean());

        assertTrue("COL3 exists", query.get(0).containsKey("COL3"));
        assertEquals("COL3 ok?", 2D, query.get(0).get("COL3").toDouble(), 0);

        assertTrue("COL4 exists", query.get(0).containsKey("COL4"));
        assertEquals("COL4 ok?", 3L, (long) query.get(0).get("COL4").toLong());

        assertTrue("COL5 exists", query.get(0).containsKey("COL5"));
        assertEquals("COL5  ok?", "ADEUS", query.get(0).get("COL5").toString());
    }

    @Test
    public void insertWithAutoCommitTest() throws Exception {
        create5ColumnsEntity();

        EntityEntry entry = entry().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS")
                .build();

        engine.persist("TEST", entry);

        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")));

        assertTrue("COL1 exists", query.get(0).containsKey("COL1"));
        assertEquals("COL1 ok?", 2, (int) query.get(0).get("COL1").toInt());

        assertTrue("COL2 exists", query.get(0).containsKey("COL2"));
        assertFalse("COL2 ok?", query.get(0).get("COL2").toBoolean());

        assertTrue("COL3 exists", query.get(0).containsKey("COL3"));
        assertEquals("COL3 ok?", 2D, query.get(0).get("COL3").toDouble(), 0);

        assertTrue("COL4 exists", query.get(0).containsKey("COL4"));
        assertEquals("COL4 ok?", 3L, (long) query.get(0).get("COL4").toLong());

        assertTrue("COL5 exists", query.get(0).containsKey("COL5"));
        assertEquals("COL5  ok?", "ADEUS", query.get(0).get("COL5").toString());
    }

    @Test
    public void insertWithControlledTransactionUsingSequenceTest() throws Exception {
        DbEntity entity = dbEntity()
                .name("TEST")
                .addColumn("COL1", INT, true)
                .addColumn("COL2", BOOLEAN)
                .addColumn("COL3", DOUBLE)
                .addColumn("COL4", LONG)
                .addColumn("COL5", STRING)
                .build();

        engine.addEntity(entity);

        EntityEntry entry = entry().set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS")
                .build();

        engine.beginTransaction();

        try {

            engine.persist("TEST", entry);
            engine.commit();
        } finally {
            if (engine.isTransactionActive()) {
                engine.rollback();
            }
        }
        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")));

        assertTrue("COL1 exists", query.get(0).containsKey("COL1"));
        assertEquals("COL1 ok?", 1, (int) query.get(0).get("COL1").toInt());

        assertTrue("COL2 exists", query.get(0).containsKey("COL2"));
        assertFalse("COL2 ok?", query.get(0).get("COL2").toBoolean());

        assertTrue("COL3 exists", query.get(0).containsKey("COL3"));
        assertEquals("COL3 ok?", 2D, query.get(0).get("COL3").toDouble(), 0);

        assertTrue("COL4 exists", query.get(0).containsKey("COL4"));
        assertEquals("COL4 ok?", 3L, (long) query.get(0).get("COL4").toLong());

        assertTrue("COL5 exists", query.get(0).containsKey("COL5"));
        assertEquals("COL5  ok?", "ADEUS", query.get(0).get("COL5").toString());
    }

    @Test
    public void queryWithIteratorWithDataTest() throws Exception {
        create5ColumnsEntity();

        EntityEntry entry = entry().set("COL1", 1).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS")
                .build();
        engine.persist("TEST", entry);

        ResultIterator it = engine.iterator(select(all()).from(table("TEST")));

        Map<String, ResultColumn> res;
        res = it.next();
        assertNotNull("result is not null", res);
        assertTrue("COL1 exists", res.containsKey("COL1"));
        assertEquals("COL1 ok?", 1, (int) res.get("COL1").toInt());

        assertTrue("COL2 exists", res.containsKey("COL2"));
        assertFalse("COL2 ok?", res.get("COL2").toBoolean());

        assertTrue("COL3 exists", res.containsKey("COL3"));
        assertEquals("COL3 ok?", 2D, res.get("COL3").toDouble(), 0);

        assertTrue("COL4 exists", res.containsKey("COL4"));
        assertEquals("COL4 ok?", 3L, (long) res.get("COL4").toLong());

        assertTrue("COL5 exists", res.containsKey("COL5"));
        assertEquals("COL5  ok?", "ADEUS", res.get("COL5").toString());

        assertNull("no more data to consume?", it.next());

        assertTrue("result set is closed?", it.isClosed());
        assertNull("next on a closed result set must return null", it.next());

        // calling close on a closed result set has no effect.
        it.close();
    }

    @Test
    public void queryWithIteratorWithNoDataTest() throws Exception {
        create5ColumnsEntity();

        ResultIterator it = engine.iterator(select(all()).from(table("TEST")));

        assertNull("result is null", it.next());

        assertNull("no more data to consume?", it.next());

        assertTrue("result set is closed?", it.isClosed());
        assertNull("next on a closed result set must return null", it.next());

        // calling close on a closed result set has no effect.
        it.close();
    }

    /**
     * Tests that an iterator created in a try-with-resources' resource specification header is automatically closed
     * once the block is exited from.
     *
     * @throws Exception If an unexpected error occurs.
     *
     * @since 2.1.12
     */
    @Test
    public void queryWithIteratorInTryWithResources() throws Exception {
        create5ColumnsEntity();

        final EntityEntry entry = entry()
                .set("COL1", 1)
                .set("COL2", false)
                .set("COL3", 2D)
                .set("COL4", 3L)
                .set("COL5", "ADEUS")
                .build();
        engine.persist("TEST", entry);

        final ResultIterator resultIterator;
        try (final ResultIterator it = engine.iterator(select(all()).from(table("TEST")))) {

            resultIterator = it;

            assertFalse(
                    "Result iterator should not be closed before exiting try-with-resources block",
                    resultIterator.isClosed()
            );
        }

        assertTrue(
                "Result iterator should be closed after exiting try-with-resources block",
                resultIterator.isClosed()
        );
    }

    @Test
    public void batchInsertTest() throws Exception {
        create5ColumnsEntity();

        engine.beginTransaction();

        try {
            EntityEntry entry = entry().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS")
                    .build();

            engine.addBatch("TEST", entry);

            entry = entry().set("COL1", 3).set("COL2", true).set("COL3", 3D).set("COL4", 4L).set("COL5", "OLA")
                    .build();

            engine.addBatch("TEST", entry);

            engine.flush();

            engine.commit();
        } finally {
            if (engine.isTransactionActive()) {
                engine.rollback();
            }
        }

        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")).orderby(column("COL1").asc()));

        // 1st
        assertTrue("COL1 exists", query.get(0).containsKey("COL1"));
        assertEquals("COL1 ok?", 2, (int) query.get(0).get("COL1").toInt());

        assertTrue("COL2 exists", query.get(0).containsKey("COL2"));
        assertFalse("COL2 ok?", query.get(0).get("COL2").toBoolean());

        assertTrue("COL3 exists", query.get(0).containsKey("COL3"));
        assertEquals("COL3 ok?", 2D, query.get(0).get("COL3").toDouble(), 0);

        assertTrue("COL4 exists", query.get(0).containsKey("COL4"));
        assertEquals("COL4 ok?", 3L, (long) query.get(0).get("COL4").toLong());

        assertTrue("COL5 exists", query.get(0).containsKey("COL5"));
        assertEquals("COL5  ok?", "ADEUS", query.get(0).get("COL5").toString());

        // 2nd

        assertTrue("COL1 exists", query.get(1).containsKey("COL1"));
        assertEquals("COL1 ok?", 3, (int) query.get(1).get("COL1").toInt());

        assertTrue("COL2 exists", query.get(1).containsKey("COL2"));
        assertTrue("COL2 ok?", query.get(1).get("COL2").toBoolean());

        assertTrue("COL3 exists", query.get(1).containsKey("COL3"));
        assertEquals("COL3 ok?", 3D, query.get(1).get("COL3").toDouble(), 0);

        assertTrue("COL4 exists", query.get(1).containsKey("COL4"));
        assertEquals("COL4 ok?", 4L, (long) query.get(1).get("COL4").toLong());

        assertTrue("COL5 exists", query.get(1).containsKey("COL5"));
        assertEquals("COL5  ok?", "OLA", query.get(1).get("COL5").toString());
    }

    @Test
    public void batchInsertAutocommitTest() throws Exception {
        create5ColumnsEntity();

        EntityEntry entry = entry().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS")
                .build();

        engine.addBatch("TEST", entry);

        entry = entry().set("COL1", 3).set("COL2", true).set("COL3", 3D).set("COL4", 4L).set("COL5", "OLA")
                .build();

        engine.addBatch("TEST", entry);

        // autocommit set to true.
        engine.flush();


        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")).orderby(column("COL1").asc()));

        // 1st
        assertTrue("COL1 exists", query.get(0).containsKey("COL1"));
        assertEquals("COL1 ok?", 2, (int) query.get(0).get("COL1").toInt());

        assertTrue("COL2 exists", query.get(0).containsKey("COL2"));
        assertFalse("COL2 ok?", query.get(0).get("COL2").toBoolean());

        assertTrue("COL3 exists", query.get(0).containsKey("COL3"));
        assertEquals("COL3 ok?", 2D, query.get(0).get("COL3").toDouble(), 0);

        assertTrue("COL4 exists", query.get(0).containsKey("COL4"));
        assertEquals("COL4 ok?", 3L, (long) query.get(0).get("COL4").toLong());

        assertTrue("COL5 exists", query.get(0).containsKey("COL5"));
        assertEquals("COL5  ok?", "ADEUS", query.get(0).get("COL5").toString());

        // 2nd

        assertTrue("COL1 exists", query.get(1).containsKey("COL1"));
        assertEquals("COL1 ok?", 3, (int) query.get(1).get("COL1").toInt());

        assertTrue("COL2 exists", query.get(1).containsKey("COL2"));
        assertTrue("COL2 ok?", query.get(1).get("COL2").toBoolean());

        assertTrue("COL3 exists", query.get(1).containsKey("COL3"));
        assertEquals("COL3 ok?", 3D, query.get(1).get("COL3").toDouble(), 0);

        assertTrue("COL4 exists", query.get(1).containsKey("COL4"));
        assertEquals("COL4 ok?", 4L, (long) query.get(1).get("COL4").toLong());

        assertTrue("COL5 exists", query.get(1).containsKey("COL5"));
        assertEquals("COL5  ok?", "OLA", query.get(1).get("COL5").toString());
    }

    /**
     * Tests that when persisting an entity in table that does not contain any auto generated values, the
     * {@link DatabaseEngine#persist(String, EntityEntry)} method returns {@code null}.
     *
     * @throws DatabaseEngineException If any error occurs.
     */
    @Test
    public void getGeneratedKeysWithNoAutoIncTest() throws DatabaseEngineException {
        final DbEntity entity = dbEntity()
            .name("TEST")
            .addColumn("COL1", STRING)
            .addColumn("COL2", STRING)
            // Set the two columns as fields of primary key, so they belong to the generated keys.
            .pkFields(ImmutableSet.of("COL1", "COL2"))
            .build();

        this.engine.addEntity(entity);

        final EntityEntry ee = entry()
                .set("COL1", "VAL1")
                .set("COL2", "VAL2")
                .build();

        assertThat(this.engine.persist("TEST", ee))
            .as("The auto generated value should be null!")
            .isNull();
    }

    /**
     * Tests that when trying to add {@link DbEntity} with multiple columns with auto incremented values, the
     * {@link DatabaseEngine#addEntity(DbEntity)} method throws a {@link DatabaseEngineException}.
     */
    @Test
    public void addMultipleAutoIncColumnsTest() {
        final DbEntity entity = dbEntity()
            .name("TEST")
            .addColumn("COL1", INT, true)
            .addColumn("COL2", INT, true)
            .build();

        assertThatCode(() -> this.engine.addEntity(entity))
            .as("The DatabaseEngine should not allow to setup a DbEntity with multiple auto incremented columns")
            .isInstanceOf(DatabaseEngineException.class);

    }

    @Test
    public void abortTransactionTest() throws DatabaseEngineException {
        DbEntity entity = dbEntity()
                .name("TEST")
                .addColumn("COL1", INT)
                .addColumn("COL2", INT)
                .build();


        engine.addEntity(entity);

        engine.beginTransaction();
        try {
            EntityEntry ee = entry()
                    .set("COL1", 1)
                    .set("COL2", 2)
                    .build();

            engine.persist("TEST", ee);

            throw new Exception();
        } catch (final Exception e) {
            // ignore
        } finally {
            assertTrue("tx active?", engine.isTransactionActive());

            engine.rollback();

            assertFalse("tx active?", engine.isTransactionActive());

            assertEquals("ret 0?", 0, engine.query(select(all()).from(table("TEST"))).size());
        }
    }

    @Test
    public void createEntityDropItAndCreateItAgainTest() throws DatabaseEngineException {
        DbEntity entity = dbEntity()
                .name("USER")
                .addColumn("COL1", INT, true)
                .pkFields("COL1")
                .build();

        engine.addEntity(entity);
        DbEntity removeEntity = engine.removeEntity("USER");

        assertNotNull(removeEntity);

        engine.addEntity(entity);
    }

    @Test
    public void dropEntityThatDoesNotExistTest() {
        DbEntity removeEntity = engine.removeEntity("TABLETHATDOESNOTEXIST");

        assertNull(removeEntity);
    }

    @Test
    public void joinsTest() throws DatabaseEngineException {

        userRolePermissionSchema();

        engine.query(
                select(all())
                        .from(
                                table("USER").alias("a").innerJoin(table("USER_ROLE").alias("b"), eq(column("a", "COL1"), column("b", "COL1")))
                        )
        );

        engine.query(
                select(all())
                        .from(
                                table("USER").alias("a")
                                        .innerJoin(table("USER_ROLE").alias("b"), eq(column("a", "COL1"), column("b", "COL1")))
                                        .innerJoin(table("ROLE").alias("c"), eq(column("b", "COL2"), column("c", "COL1")))
                        )
        );

        engine.query(
                select(all())
                        .from(
                                table("USER").alias("a").rightOuterJoin(table("USER_ROLE").alias("b"), eq(column("a", "COL1"), column("b", "COL1")))
                        )
        );

        engine.query(
                select(all())
                        .from(
                                table("USER").alias("a").leftOuterJoin(table("USER_ROLE").alias("b"), eq(column("a", "COL1"), column("b", "COL1")))
                        )
        );
    }

    @Test
    public void joinATableWithQueryTest() throws DatabaseEngineException {
        userRolePermissionSchema();

        engine.query(
                select(all())
                        .from(
                                table("USER").alias("a")
                                        .innerJoin(
                                                select(column("COL1"))
                                                        .from(table("USER")).alias("b")
                                                , eq(column("a", "COL1"), column("b", "COL1"))
                                        )
                        )
        );
    }

    @Test
    public void joinAQueryWithATableTest() throws DatabaseEngineException {
        userRolePermissionSchema();

        engine.query(
                select(all())
                        .from(
                                select(column("COL1"))
                                        .from(table("USER")).alias("b")
                                        .innerJoin(
                                                table("USER").alias("a")
                                                , eq(column("a", "COL1"), column("b", "COL1"))
                                        )
                        )
        );
    }

    @Test
    public void joinTwoQueriesTest() throws DatabaseEngineException {
        userRolePermissionSchema();

        engine.query(
                select(all())
                        .from(
                                select(column("COL1"))
                                        .from(table("USER")).alias("a")
                                        .innerJoin(
                                                select(column("COL1"))
                                                        .from(table("USER")).alias("b")
                                                , eq(column("a", "COL1"), column("b", "COL1"))
                                        )
                        )
        );
    }

    @Test
    public void joinThreeQueriesTest() throws DatabaseEngineException {
        userRolePermissionSchema();

        engine.query(
                select(all())
                        .from(
                                select(column("COL1"))
                                        .from(table("USER")).alias("a")
                                        .innerJoin(
                                                select(column("COL1"))
                                                        .from(table("USER")).alias("b")
                                                , eq(column("a", "COL1"), column("b", "COL1"))
                                        )
                                        .rightOuterJoin(
                                                select(column("COL1"))
                                                        .from(table("USER")).alias("c")
                                                , eq(column("a", "COL1"), column("c", "COL1"))
                                        )
                        )
        );
    }

    @Test
    @Category(SkipTestCockroachDB.class)
    // unimplemented in CockroachDB: views do not currently support * expressions
    // https://github.com/cockroachdb/cockroach/issues/10028
    public void createAndDropViewTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.executeUpdate(
                createView("VN").as(select(all()).from(table("TEST")))
        );

        engine.dropView("VN");
    }

    @Test
    @Category(SkipTestCockroachDB.class)
    // unimplemented in CockroachDB: views do not currently support * expressions
    // https://github.com/cockroachdb/cockroach/issues/10028
    public void createOrReplaceViewTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.executeUpdate(
                createView("VN").as(select(all()).from(table("TEST"))).replace()
        );

        engine.dropView("VN");
    }

    @Test
    public void distinctTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.query(
                select(all()).distinct()
                        .from(table("TEST"))
        );
    }

    @Test
    public void distinctAndLimitTogetherTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.query(
                select(all()).distinct()
                        .from(table("TEST")).limit(2)
        );
    }

    @Test
    public void notEqualTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.query(
                select(all())
                        .from(table("TEST"))
                        .where(neq(column("COL1"), k(1)))
        );
    }

    /**
     * Tests that the {@link SqlBuilder#in(Expression, Expression) IN} clause with a value filters a row correctly.
     *
     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
     */
    @Test
    public void inTest() throws DatabaseEngineException {
        runInClauseTest(in(column("COL1"), L((k(1)))));
    }

    /**
     * Tests that the {@link SqlBuilder#in(Expression, Expression) IN} clause with SELECT filters a row correctly.
     *
     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
     */
    @Test
    public void inSelectTest() throws DatabaseEngineException {
        runInClauseTest(in(
                column("COL1"),
                select(column("COL1")).from(table("TEST")).where(eq(column("COL1"), k(1)))
        ));
    }

    /**
     * Tests that the {@link SqlBuilder#in(Expression, Expression) IN} clause with values filters a row correctly,
     * when many values are provided.
     * <p>
     * This is a regression test for Oracle, which only supports up to 1000 values in IN clauses; the test uses
     * 20000 values.
     *
     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
     */
    @Test
    public void inManyValuesTest() throws DatabaseEngineException {
        final List<Expression> numExprs = IntStream.rangeClosed(-19998, 1)
                .mapToObj(SqlBuilder::k)
                .collect(Collectors.toList());

        runInClauseTest(in(column("COL1"), L(numExprs)));
    }

    /**
     * Tests that the {@link SqlBuilder#notIn(Expression, Expression) (Expression, Expression) negated IN} clause
     * with a value filters a row correctly.
     *
     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
     */
    @Test
    public void notInTest() throws DatabaseEngineException {
        runInClauseTest(notIn(column("COL1"), L((k(2)))));
    }

    /**
     * Tests that the {@link SqlBuilder#notIn(Expression, Expression) negated IN} clause with SELECT filters a row correctly.
     *
     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
     */
    @Test
    public void notInSelectTest() throws DatabaseEngineException {
        runInClauseTest(notIn(
                column("COL1"),
                select(column("COL1")).from(table("TEST")).where(eq(column("COL1"), k(2)))
        ));
    }

    /**
     * Tests that the {@link SqlBuilder#notIn(Expression, Expression) negated IN} clause with a value filters a row
     * correctly, when many values are provided.
     * <p>
     * This is a regression test for Oracle, which only supports up to 1000 values in IN clauses; the test uses
     * 20000 values.
     *
     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
     */
    @Test
    public void notInManyValuesTest() throws DatabaseEngineException {
        final List<Expression> numExprs = IntStream.rangeClosed(2, 20001)
                .mapToObj(SqlBuilder::k)
                .collect(Collectors.toList());

        runInClauseTest(notIn(column("COL1"), L(numExprs)));
    }

    /**
     * Common code to run IN clause tests.
     * <p>
     * This creates 2 entries in the database:
     * <table>
     *     <tr><td>COL1</td><td>COL5</td></tr>
     *     <tr><td>1</td><td>s1</td></tr>
     *     <tr><td>2</td><td>s2</td></tr>
     * </table>
     * <p>
     * The verifications expect the provided {@code whereInExpression} to filter the entries such that only the first
     * one is returned.
     *
     * @param whereInExpression The {@link Expression} to use in the WHERE clause of the query.
     * @throws DatabaseEngineException If a DB error occurs.
     */
    private void runInClauseTest(final Expression whereInExpression) throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.persist("TEST", entry().set("COL1", 1).set("COL5", "s1").build());
        engine.persist("TEST", entry().set("COL1", 2).set("COL5", "s2").build());

        final List<Map<String, ResultColumn>> results = engine.query(
                select(all())
                        .from(table("TEST"))
                        .where(whereInExpression)
        );

        assertThat(results)
                .as("query should return only 1 result")
                .hasSize(1)
                .element(0)
                .as("result should have have value '1'")
                .extracting(result -> result.get("COL1").toInt())
                .isEqualTo(1);
    }

    @Test
    public void booleanTrueComparisonTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        EntityEntry entry1 = entry()
                .set("COL1", 1)
                .set("COL2", true)
                .set("COL3", 1)
                .set("COL4", 1)
                .set("COL5", "val 1")
                .build();
        engine.persist("TEST", entry1, false);

        EntityEntry entry2 = entry()
                .set("COL1", 1)
                .set("COL2", false)
                .set("COL3", 1)
                .set("COL4", 1)
                .set("COL5", "val 1")
                .build();
        engine.persist("TEST", entry2, false);

        List<Map<String, ResultColumn>> rows = engine.query(
                select(all())
                        .from(table("TEST"))
                        .where(
                                eq(column("COL2"), k(true))
                        )
        );

        assertEquals(1, rows.size());
    }

    @Test
    public void booleanFalseComparisonTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        EntityEntry entry1 = entry()
                .set("COL1", 1)
                .set("COL2", true)
                .set("COL3", 1)
                .set("COL4", 1)
                .set("COL5", "val 1")
                .build();
        engine.persist("TEST", entry1, false);

        EntityEntry entry2 = entry()
                .set("COL1", 1)
                .set("COL2", false)
                .set("COL3", 1)
                .set("COL4", 1)
                .set("COL5", "val 1")
                .build();
        engine.persist("TEST", entry2, false);

        List<Map<String, ResultColumn>> rows = engine.query(
                select(all())
                        .from(table("TEST"))
                        .where(
                                eq(column("COL2"), k(false))
                        )
        );

        assertEquals(1, rows.size());
    }

    @Test
    public void coalesceTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.query(
                select(all())
                        .from(table("TEST"))
                        .where(
                                eq(coalesce(column("COL2"), k(false)), k(false))
                        )
        );
    }

    @Test
    public void multipleCoalesceTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.query(
                select(all())
                        .from(table("TEST"))
                        .where(
                                eq(coalesce(column("COL2"), k(false), k(true)), k(false))
                        )
        );
    }

    @Test
    public void betweenTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.query(
                select(all())
                        .from(table("TEST"))
                        .where(
                                between(column("COL1"), k(1), k(2))
                        )
        );
    }



    @Test
    public void testCast() throws DatabaseEngineException {

        final Query query = select(
                cast(k("22"), INT).alias("int"),
                cast(k(22), STRING).alias("string"),
                cast(k("1"), BOOLEAN).alias("bool"),
                cast(k("22"), DOUBLE).alias("double"),
                cast(k(22), LONG).alias("long")
        );

        final Map<String, ResultColumn> result = engine.query(query).get(0);

        assertEquals("Result must be 22", new Integer(22), result.get("int").toInt());
        assertEquals("Result must be '22'", "22", result.get("string").toString());
        assertEquals("Result must be true", true, result.get("bool").toBoolean());
        assertEquals("Result must be 22.0", new Double(22), result.get("double").toDouble());
        assertEquals("Result must be 22", new Long(22), result.get("long").toLong());
    }

    @Test
    public void testCastColumns() throws DatabaseEngineException {

        final DbEntity entity = dbEntity()
                .name("TEST")
                .addColumn("COL_INT", INT)
                .addColumn("COL_STRING", STRING)
                .addColumn("COL_CAST_INT", INT)
                .addColumn("COL_CAST_STRING", STRING)
                .pkFields("COL_INT")
                .build();

        engine.addEntity(entity);

        EntityEntry entry = entry()
                .set("COL_INT", 123)
                .set("COL_STRING", "321")
                .build();

        engine.persist("TEST", entry);

        // test CAST when writing values
        final Update update = update(table("TEST"))
                .set(eq(column("COL_CAST_INT"), cast(k("3211"), INT)),
                        eq(column("COL_CAST_STRING"), cast(k(1233), STRING)))
                .where(eq(column("COL_INT"), k(123)));

        engine.executeUpdate(update);

        // test CAST when reading values
        Query query =
                select(
                        cast(column("COL_INT"), STRING).alias("COL_INT_string"),
                        cast(column("COL_STRING"), INT).alias("COL_STRING_int"),
                        column("COL_CAST_INT"),
                        column("COL_CAST_STRING")
                ).from(table("TEST"));

        Map<String, ResultColumn> result = engine.query(query).get(0);

        assertEquals("The value of COL_INT cast to string must be '123'", "123", result.get("COL_INT_string").toString());
        assertEquals("The value of COL_STRING cast to int must be 321", new Integer(321), result.get("COL_STRING_int").toInt());
        assertEquals("The value of COL_CAST_INT must be 3211", Integer.valueOf(3211), result.get("COL_CAST_INT").toInt());
        assertEquals("The value of COL_CAST_STRING must be '1233'", "1233", result.get("COL_CAST_STRING").toString());

        /*
         Until now the test only really checks if the CAST doesn't cause any errors because
          - when writing values into the DB it automatically casts into the column data type
          - when reading values from the DB, the test reads the results from the ResultColumn as the desired type
         Even if we used a function, it is likely the DB would try to cast the parameters to the expected type.
         To effectively test if CAST works, we need to check if DB sorting considers the column a string or a number.
         */
        entry = entry()
                .set("COL_INT", 1000)
                .set("COL_STRING", "321000")
                .build();

        engine.persist("TEST", entry);

        query = select(column("COL_INT")).from(table("TEST")).orderby(column("COL_INT"));
        String firstResult = engine.query(query).get(0).get("COL_INT").toString();
        assertEquals("sorting should have considered the sort column as a number (123 < 1000)", "123", firstResult);

        query = select(column("COL_INT"), cast(column("COL_INT"), STRING).alias("COL_INT_string"))
                .from(table("TEST"))
                .orderby(column("COL_INT_string"));
        firstResult = engine.query(query).get(0).get("COL_INT").toString();
        assertEquals("sorting should have considered the sort column as a string (1000 < 123)", "1000", firstResult);
    }

    protected void userRolePermissionSchema() throws DatabaseEngineException {
        DbEntity entity = dbEntity()
                .name("USER")
                .addColumn("COL1", INT, true)
                .pkFields("COL1")
                .build();

        engine.addEntity(entity);

        entity = dbEntity()
                .name("ROLE")
                .addColumn("COL1", INT, true)
                .pkFields("COL1")
                .build();

        engine.addEntity(entity);

        entity = dbEntity()
                .name("USER_ROLE")
                .addColumn("COL1", INT)
                .addColumn("COL2", INT)
                .addFk(dbFk()
                                .addColumn("COL1")
                                .referencedTable("USER")
                                .addReferencedColumn("COL1")
                                .build(),
                        dbFk()
                                .addColumn("COL2")
                                .referencedTable("ROLE")
                                .addReferencedColumn("COL1")
                                .build()
                )
                .pkFields("COL1", "COL2")
                .build();

        engine.addEntity(entity);
    }

    @Test
    public void testAndWhere() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
                .build());
        engine.persist("TEST", entry().set("COL1", 2).set("COL5", "TESTE")
                .build());
        engine.persist("TEST", entry().set("COL1", 3).set("COL5", "TeStE")
                .build());
        engine.persist("TEST", entry().set("COL1", 4).set("COL5", "tesTte")
                .build());

        final List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")).where(eq(column("COL1"), k(1))).andWhere(eq(column("COL5"), k("teste"))));

        assertEquals("Resultset must have only one result", 1, query.size());
        assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
        assertEquals("COL5 must be teste", "teste", query.get(0).get("COL5").toString());
    }

    @Test
    public void testAndWhereMultiple() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
                .build());
        engine.persist("TEST", entry().set("COL1", 2).set("COL5", "TESTE")
                .build());
        engine.persist("TEST", entry().set("COL1", 3).set("COL5", "TeStE")
                .build());
        engine.persist("TEST", entry().set("COL1", 4).set("COL5", "tesTte")
                .build());

        final List<Map<String, ResultColumn>> query = engine.query(
                select(all())
                        .from(table("TEST"))
                        .where(
                                or(
                                        eq(column("COL1"), k(1)),
                                        eq(column("COL1"), k(4))
                                )
                        )
                        .andWhere(
                                or(
                                        eq(column("COL5"), k("teste")),
                                        eq(column("COL5"), k("TESTE"))
                                )
                        )
        );

        assertEquals("Resultset must have only one result", 1, query.size());
        assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
        assertEquals("COL5 must be teste", "teste", query.get(0).get("COL5").toString());
    }

    @Test
    public void testAndWhereMultipleCheckAndEnclosed() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
                .build());
        engine.persist("TEST", entry().set("COL1", 2).set("COL5", "TESTE")
                .build());
        engine.persist("TEST", entry().set("COL1", 3).set("COL5", "TeStE")
                .build());
        engine.persist("TEST", entry().set("COL1", 4).set("COL5", "tesTte")
                .build());

        final List<Map<String, ResultColumn>> query = engine.query(
                select(all())
                        .from(table("TEST"))
                        .where(
                                or(
                                        eq(column("COL1"), k(1)),
                                        eq(column("COL1"), k(4))
                                )
                        )
                        .andWhere(
                                or(
                                        eq(column("COL5"), k("teste")),
                                        eq(column("COL5"), k("tesTte"))
                                )
                        )
        );

        assertEquals("Resultset must have only one result", 2, query.size());
        assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
        assertEquals("COL5 must be teste", "teste", query.get(0).get("COL5").toString());
        assertEquals("COL1 must be 1", 4, query.get(1).get("COL1").toInt().intValue());
        assertEquals("COL5 must be teste", "tesTte", query.get(1).get("COL5").toString());
    }

    @Test
    public void testStringAgg() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.persist("TEST", entry().set("COL1", 1).set("COL5", "TESTE")
                .build());
        engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
                .build());
        engine.persist("TEST", entry().set("COL1", 2).set("COL5", "TeStE")
                .build());
        engine.persist("TEST", entry().set("COL1", 2).set("COL5", "tesTte")
                .build());

        final List<Map<String, ResultColumn>> query = engine.query(
                select(column("COL1"), stringAgg(column("COL5")).alias("agg"))
                        .from(table("TEST"))
                        .groupby(column("COL1"))
                        .orderby(column("COL1").asc())
        );

        assertEquals("Resultset must have only 2 results", 2, query.size());
        assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
        assertEquals("COL5 must be TESTE,teste", "TESTE,teste", query.get(0).get("agg").toString());
        assertEquals("COL1 must be 2", 2, query.get(1).get("COL1").toInt().intValue());
        assertEquals("COL5 must be TeStE,tesTte", "TeStE,tesTte", query.get(1).get("agg").toString());
    }

    @Test
    public void testStringAggDelimiter() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.persist("TEST", entry().set("COL1", 1).set("COL5", "TESTE")
                .build());
        engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
                .build());
        engine.persist("TEST", entry().set("COL1", 2).set("COL5", "TeStE")
                .build());
        engine.persist("TEST", entry().set("COL1", 2).set("COL5", "tesTte")
                .build());

        final List<Map<String, ResultColumn>> query = engine.query(
                select(column("COL1"), stringAgg(column("COL5")).delimiter(';').alias("agg"))
                        .from(table("TEST"))
                        .groupby(column("COL1"))
                        .orderby(column("COL1").asc())
        );

        assertEquals("Resultset must have only 2 results", 2, query.size());
        assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
        assertEquals("COL5 must be TESTE;teste", "TESTE;teste", query.get(0).get("agg").toString());
        assertEquals("COL1 must be 2", 2, query.get(1).get("COL1").toInt().intValue());
        assertEquals("COL5 must be TeStE;tesTte", "TeStE;tesTte", query.get(1).get("agg").toString());
    }

    @Test
    public void testStringAggDistinct() throws DatabaseEngineException {
        assumeTrue("This test is only valid for engines that support StringAggDistinct",
                this.engine.isStringAggDistinctCapable());

        create5ColumnsEntity();

        engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
                .build());
        engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
                .build());
        engine.persist("TEST", entry().set("COL1", 2).set("COL5", "TeStE")
                .build());
        engine.persist("TEST", entry().set("COL1", 2).set("COL5", "tesTte")
                .build());

        final List<Map<String, ResultColumn>> query = engine.query(
                select(column("COL1"), stringAgg(column("COL5")).distinct().alias("agg"))
                        .from(table("TEST"))
                        .groupby(column("COL1"))
                        .orderby(column("COL1").asc())
        );

        assertEquals("Resultset must have only 2 results", 2, query.size());
        assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
        assertEquals("COL5 must be teste", "teste", query.get(0).get("agg").toString());
        assertEquals("COL1 must be 2", 2, query.get(1).get("COL1").toInt().intValue());
        assertEquals("COL5 must be TeStE,tesTte", "TeStE,tesTte", query.get(1).get("agg").toString());
    }

    @Test
    public void testStringAggNotStrings() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.persist("TEST", entry().set("COL1", 1).set("COL5", "TESTE")
                .build());
        engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
                .build());
        engine.persist("TEST", entry().set("COL1", 2).set("COL5", "TeStE")
                .build());
        engine.persist("TEST", entry().set("COL1", 2).set("COL5", "tesTte")
                .build());

        final List<Map<String, ResultColumn>> query = engine.query(
                select(column("COL1"), stringAgg(column("COL1")).alias("agg"))
                        .from(table("TEST"))
                        .groupby(column("COL1"))
                        .orderby(column("COL1").asc())
        );

        assertEquals("Resultset must have only 2 results", 2, query.size());
        assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
        assertEquals("COL5 must be 1,1", "1,1", query.get(0).get("agg").toString());
        assertEquals("COL1 must be 2", 2, query.get(1).get("COL1").toInt().intValue());
        assertEquals("COL5 must be 2,2", "2,2", query.get(1).get("agg").toString());
    }

    @Test
    @Category(SkipTestCockroachDB.class)
    public void dropPrimaryKeyWithOneColumnTest() throws Exception {
        DbEntity entity =
                dbEntity()
                        .name("TEST")
                        .addColumn("COL1", INT)
                        .addColumn("COL2", BOOLEAN)
                        .addColumn("COL3", DOUBLE)
                        .addColumn("COL4", LONG)
                        .addColumn("COL5", STRING)
                        .pkFields("COL1")
                        .build();
        engine.addEntity(entity);
        engine.executeUpdate(dropPK(table("TEST")));
    }

    @Test
    @Category(SkipTestCockroachDB.class)
    public void dropPrimaryKeyWithTwoColumnsTest() throws Exception {
        DbEntity entity =
                dbEntity()
                        .name("TEST")
                        .addColumn("COL1", INT)
                        .addColumn("COL2", BOOLEAN)
                        .addColumn("COL3", DOUBLE)
                        .addColumn("COL4", LONG)
                        .addColumn("COL5", STRING)
                        .pkFields("COL1", "COL4")
                        .build();
        engine.addEntity(entity);
        engine.executeUpdate(dropPK(table("TEST")));
    }

    @Test
    public void alterColumnWithConstraintTest() throws DatabaseEngineException {
        DbEntity entity =
                dbEntity()
                        .name("TEST")
                        .addColumn("COL1", INT)
                        .addColumn("COL2", BOOLEAN)
                        .addColumn("COL3", DOUBLE)
                        .addColumn("COL4", LONG)
                        .addColumn("COL5", STRING)
                        .build();

        engine.addEntity(entity);

        engine.executeUpdate(new AlterColumn(table("TEST"), new DbColumn.Builder().name("COL1").type(DbColumnType.INT).addConstraint(DbColumnConstraint
                .NOT_NULL)
                .build()));
    }

    @Test
    @Category(SkipTestCockroachDB.class)
    public void alterColumnToDifferentTypeTest() throws DatabaseEngineException {
        DbEntity entity =
                dbEntity()
                        .name("TEST")
                        .addColumn("COL1", INT)
                        .addColumn("COL2", BOOLEAN)
                        .addColumn("COL3", DOUBLE)
                        .addColumn("COL4", LONG)
                        .addColumn("COL5", STRING)
                        .build();

        engine.addEntity(entity);

        engine.executeUpdate(new AlterColumn(table("TEST"), dbColumn().name("COL1").type(DbColumnType.STRING)
                .build()));
    }

    @Test
    public void createTableWithDefaultsTest() throws DatabaseEngineException, DatabaseFactoryException {
        DbEntity.Builder entity =
                dbEntity()
                        .name("TEST")
                        .addColumn("COL1", INT, new K(1))
                        .addColumn("COL2", BOOLEAN, new K(false))
                        .addColumn("COL3", DOUBLE, new K(2.2d))
                        .addColumn("COL4", LONG, new K(3L))
                        .pkFields("COL1");

        engine.addEntity(entity.build());

        final String ec = engine.escapeCharacter();
        engine.executeUpdate("INSERT INTO " + quotize("TEST", ec) + " (" + quotize("COL1", ec) + ") VALUES (10)");

        List<Map<String, ResultColumn>> test = engine.query(select(all()).from(table("TEST")));
        assertEquals("Check size of records", 1, test.size());
        Map<String, ResultColumn> record = test.get(0);
        assertEquals("Check COL1", 10, record.get("COL1").toInt().intValue());
        assertEquals("Check COL2", false, record.get("COL2").toBoolean());
        assertEquals("Check COL3", 2.2d, record.get("COL3").toDouble(), 0D);
        assertEquals("Check COL4", 3L, record.get("COL4").toLong().longValue());


        final DbEntity entity1 = entity
                .addColumn("COL5", STRING, new K("mantorras"), NOT_NULL)
                .addColumn("COL6", BOOLEAN, new K(true), NOT_NULL)
                .addColumn("COL7", INT, new K(7), NOT_NULL)
                .build();

        final Properties propertiesCreate = new Properties();
        for (Map.Entry<Object, Object> prop : properties.entrySet()) {
            propertiesCreate.setProperty(prop.getKey().toString(), prop.getValue().toString());
        }
        propertiesCreate.setProperty(SCHEMA_POLICY, "create");

        final DatabaseEngine connection2 = DatabaseFactory.getConnection(propertiesCreate);
        connection2.updateEntity(entity1);

        test = connection2.query(select(all()).from(table("TEST")));
        assertEquals("Check size of records", 1, test.size());
        record = test.get(0);
        assertEquals("Check COL1", 10, record.get("COL1").toInt().intValue());
        assertEquals("Check COL2", false, record.get("COL2").toBoolean());
        assertEquals("Check COL3", 2.2d, record.get("COL3").toDouble(), 1e-9);
        assertEquals("Check COL4", 3L, record.get("COL4").toLong().longValue());
        assertEquals("Check COL5", "mantorras", record.get("COL5").toString());
        assertEquals("Check COL6", true, record.get("COL6").toBoolean());
        assertEquals("Check COL7", 7, record.get("COL7").toInt().intValue());
        connection2.close();
    }

    @Test
    public void defaultValueOnBooleanColumnsTest() throws DatabaseEngineException {
        DbEntity.Builder entity =
                dbEntity()
                        .name("TEST")
                        .addColumn("COL1", INT, new K(1))
                        .addColumn("COL2", BOOLEAN, new K(false), NOT_NULL)
                        .addColumn("COL3", DOUBLE, new K(2.2d))
                        .addColumn("COL4", LONG, new K(3L))
                        .pkFields("COL1");

        engine.addEntity(entity.build());

        engine.persist("TEST", entry().build());
        Map<String, ResultColumn> row = engine.query(select(all()).from(table("TEST"))).get(0);

        assertEquals("", 1, row.get("COL1").toInt().intValue());
        assertFalse("", row.get("COL2").toBoolean());
        assertEquals("", 2.2d, row.get("COL3").toDouble(), 0D);
        assertEquals("", 3L, row.get("COL4").toLong().longValue());
    }

    @Test
    public void upperTest() throws DatabaseEngineException {
        create5ColumnsEntity();
        engine.persist("TEST", entry().set("COL5", "ola").build());
        assertEquals("text is uppercase", "OLA", engine.query(select(upper(column("COL5")).alias("RES")).from(table("TEST"))).get(0).get("RES").toString());
    }

    @Test
    public void lowerTest() throws DatabaseEngineException {
        create5ColumnsEntity();
        engine.persist("TEST", entry().set("COL5", "OLA").build());
        assertEquals("text is lowercase", "ola", engine.query(select(lower(column("COL5")).alias("RES")).from(table("TEST"))).get(0).get("RES").toString());
    }

    @Test
    public void internalFunctionTest() throws DatabaseEngineException {
        create5ColumnsEntity();
        engine.persist("TEST", entry().set("COL5", "OLA").build());
        assertEquals("text is uppercase", "ola", engine.query(select(f("LOWER", column("COL5")).alias("RES")).from(table("TEST"))).get(0).get("RES")
                .toString());
    }

    @Test
    public void entityEntryHashcodeTest() {
        Map<String, Object> map = new HashMap<>();
        map.put("id1", "val1");
        map.put("id2", "val2");
        map.put("id3", "val3");
        map.put("id4", "val4");

        EntityEntry entry = entry()
                .set(map)
                .build();

        assertEquals("entry's hashCode() matches map's hashCode()", map.hashCode(), entry.hashCode());
    }

    @Test
    public void testBlob() throws Exception {
        DbEntity entity = dbEntity()
                .name("TEST")
                .addColumn("COL1", STRING)
                .addColumn("COL2", BLOB)
                .build();

        engine.addEntity(entity);
        EntityEntry entry = entry()
                .set("COL1", "CENINHAS")
                .set("COL2", new BlobTest(1, "name"))
                .build();

        engine.persist("TEST", entry);

        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table("TEST")));
        assertEquals("CENINHAS", result.get(0).get("COL1").toString());
        assertEquals(new BlobTest(1, "name"), result.get(0).get("COL2").<BlobTest>toBlob());

        BlobTest updBlob = new BlobTest(2, "cenas");

        final ByteArrayOutputStream bos = new ByteArrayOutputStream();
        final ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(updBlob);

        Update upd = update(table("TEST")).set(eq(column("COL2"), lit("?"))).where(eq(column("COL1"), k("CENINHAS")));

        engine.createPreparedStatement("testBlob", upd);

        engine.setParameters("testBlob", bos.toByteArray());

        engine.executePSUpdate("testBlob");

        result = engine.query(select(all()).from(table("TEST")));
        assertEquals("CENINHAS", result.get(0).get("COL1").toString());
        assertEquals(updBlob, result.get(0).get("COL2").<BlobTest>toBlob());
    }

    @Test
    public void testCLOB() throws Exception {
        DbEntity entity = dbEntity()
                .name("TEST")
                .addColumn("COL1", STRING)
                .addColumn("COL2", CLOB)
                .build();

        engine.addEntity(entity);

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 4000; i++) {
            sb.append("a");
        }

        String bigString = sb.toString();
        EntityEntry entry = entry().set("COL1", "CENINHAS").set("COL2", bigString)
                .build();

        engine.persist("TEST", entry);

        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table("TEST")));
        assertEquals("CENINHAS", result.get(0).get("COL1").toString());
        assertEquals(bigString, result.get(0).get("COL2").<String>toBlob());
    }

    @Test
    public void addDropColumnWithDropCreateTest() throws DatabaseEngineException {
        DbEntity.Builder entity = dbEntity()
                .name("TEST")
                .addColumn("COL1", INT, true)
                .addColumn("COL2", BOOLEAN)
                .addColumn("COL3", DOUBLE)
                .addColumn("COL4", LONG)
                .addColumn("COL
