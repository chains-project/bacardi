<code_analysis>
1. The error message indicates that the constructor for org.hamcrest.core.StringContains is now defined to accept only a single java.lang.String argument instead of two (a boolean and a String). The error occurs at several lines where new StringContains(false, String.format(...)) is used.
2. In the client code, the problematic areas are in the test methods (shouldPullPushedByTag, shouldPullPushedByDigest) and the private matcher methods (manifestPushed, layersPushed, layersAlreadyExist), where the boolean parameter “false” is passed to StringContains.
3. To fix this, we need to remove the extra boolean parameter and call the constructor with only the substring to match. This aligns with the updated Hamcrest dependency.
4. The specific modifications are:
   - Replace new StringContains(false, String.format(...)) with new StringContains(String.format(...)) in all relevant locations.
   - All other code is left unchanged to preserve functionality.
</code_analysis>

```java
/*
 * The MIT License (MIT) Copyright (c) 2020-2023 artipie.com
 * https://github.com/artipie/docker-adapter/LICENSE.txt
 */
package com.artipie.docker.http;

import com.artipie.asto.memory.InMemoryStorage;
import com.artipie.docker.asto.AstoDocker;
import com.artipie.docker.junit.DockerClient;
import com.artipie.docker.junit.DockerClientSupport;
import com.artipie.docker.junit.DockerRepository;
import org.hamcrest.Matcher;
import org.hamcrest.MatcherAssert;
import org.hamcrest.Matchers;
import org.hamcrest.core.StringContains;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

/**
 * Integration test for {@link DockerSlice}.
 *
 * @since 0.2
 */
@SuppressWarnings("PMD.AvoidDuplicateLiterals")
@DockerClientSupport
final class DockerSliceITCase {
    /**
     * Example docker image to use in tests.
     */
    private Image image;

    /**
     * Docker client.
     */
    private DockerClient client;

    /**
     * Docker repository.
     */
    private DockerRepository repository;

    @BeforeEach
    void setUp() throws Exception {
        this.repository = new DockerRepository(
            new AstoDocker(new InMemoryStorage())
        );
        this.repository.start();
        this.image = this.prepareImage();
    }

    @AfterEach
    void tearDown() {
        this.repository.stop();
    }

    @Test
    void shouldPush() throws Exception {
        final String output = this.client.run("push", this.image.remote());
        MatcherAssert.assertThat(
            output,
            Matchers.allOf(this.layersPushed(), this.manifestPushed())
        );
    }

    @Test
    void shouldPushExisting() throws Exception {
        this.client.run("push", this.image.remote());
        final String output = this.client.run("push", this.image.remote());
        MatcherAssert.assertThat(
            output,
            Matchers.allOf(this.layersAlreadyExist(), this.manifestPushed())
        );
    }

    @Test
    void shouldPullPushedByTag() throws Exception {
        this.client.run("push", this.image.remote());
        this.client.run("image", "rm", this.image.name());
        this.client.run("image", "rm", this.image.remote());
        final String output = this.client.run("pull", this.image.remote());
        MatcherAssert.assertThat(
            output,
            new StringContains(String.format("Status: Downloaded newer image for %s", this.image.remote()))
        );
    }

    @Test
    void shouldPullPushedByDigest() throws Exception {
        this.client.run("push", this.image.remote());
        this.client.run("image", "rm", this.image.name());
        this.client.run("image", "rm", this.image.remote());
        final String output = this.client.run("pull", this.image.remoteByDigest());
        MatcherAssert.assertThat(
            output,
            new StringContains(String.format("Status: Downloaded newer image for %s", this.image.remoteByDigest()))
        );
    }

    private Image prepareImage() throws Exception {
        final Image tmpimg = new Image.ForOs();
        final String original = tmpimg.remoteByDigest();
        this.client.run("pull", original);
        final String local = "my-test";
        this.client.run("tag", original, String.format("%s:latest", local));
        final Image img = new Image.From(
            this.repository.url(),
            local,
            tmpimg.digest(),
            tmpimg.layer()
        );
        this.client.run("tag", original, img.remote());
        return img;
    }

    private Matcher<String> manifestPushed() {
        return new StringContains(String.format("latest: digest: %s", this.image.digest()));
    }

    private Matcher<String> layersPushed() {
        return new StringContains(String.format("%s: Pushed", this.image.layer()));
    }

    private Matcher<String> layersAlreadyExist() {
        return new StringContains(
            String.format("%s: Layer already exists", this.image.layer())
        );
    }
}
```
