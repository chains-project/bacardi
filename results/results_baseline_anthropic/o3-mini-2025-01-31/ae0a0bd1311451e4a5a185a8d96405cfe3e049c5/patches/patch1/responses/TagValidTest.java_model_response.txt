<code_analysis>
1. The error message indicates that the StringContains constructor is now defined to accept only a single String argument, but the test is attempting to pass a boolean and a String. The two problematic lines are in the second parameterized test, where new StringContains(true, "Invalid tag") and new StringContains(false, original) are used.
2. In the client code, these constructors are used to check if the exception message contains "Invalid tag" and simultaneously does not include the invalid tag value. With the breaking dependency update (likely a newer version of Hamcrest), these constructors have been changed or removed.
3. To fix the issue:
   - Replace use of new StringContains(true, "Invalid tag") with a matcher that asserts the message contains the substring "Invalid tag" (e.g. using containsString("Invalid tag") from org.hamcrest.CoreMatchers).
   - Replace new StringContains(false, original) with a matcher that asserts that the message does not contain the substring original (e.g. using not(containsString(original)) from org.hamcrest.CoreMatchers).
4. Change necessary imports by adding static imports for containsString and not. This ensures that the matcher calls are consistent with the updated Hamcrest dependency.
</code_analysis>

```java
/*
 * The MIT License (MIT) Copyright (c) 2020-2022 artipie.com
 * https://github.com/artipie/docker-adapter/LICENSE.txt
 */
package com.artipie.docker;

import com.artipie.docker.error.InvalidTagNameException;
import java.util.Arrays;
import org.hamcrest.MatcherAssert;
import org.hamcrest.core.AllOf;
import org.hamcrest.core.IsEqual;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.not;

/**
 * Tests for {@link Tag.Valid}.
 *
 * @since 0.2
 */
class TagValidTest {

    @ParameterizedTest
    @ValueSource(strings = {
        "latest",
        "1.0",
        "my-tag",
        "MY_TAG",
        "My.Tag.1",
        "_some_tag",
        //@checkstyle LineLengthCheck (1 line)
        "01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567"
    })
    void shouldGetValueWhenValid(final String original) {
        final Tag.Valid tag = new Tag.Valid(original);
        MatcherAssert.assertThat(tag.valid(), new IsEqual<>(true));
        MatcherAssert.assertThat(tag.value(), new IsEqual<>(original));
    }

    @ParameterizedTest
    @ValueSource(strings = {
        "",
        ".0",
        "*",
        "\u00ea",
        "-my-tag",
        //@checkstyle LineLengthCheck (1 line)
        "012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"
    })
    void shouldFailToGetValueWhenInvalid(final String original) {
        final Tag.Valid tag = new Tag.Valid(original);
        MatcherAssert.assertThat(tag.valid(), new IsEqual<>(false));
        final Throwable throwable = Assertions.assertThrows(
            InvalidTagNameException.class,
            tag::value
        );
        MatcherAssert.assertThat(
            throwable.getMessage(),
            new AllOf<>(
                Arrays.asList(
                    containsString("Invalid tag"),
                    not(containsString(original))
                )
            )
        );
    }
}
```
