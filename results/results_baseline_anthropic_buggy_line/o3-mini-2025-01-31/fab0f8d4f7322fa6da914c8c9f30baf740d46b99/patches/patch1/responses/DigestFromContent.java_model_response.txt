<code_analysis>
1. The error message indicates that the packages and classes from the cactoos library – specifically org.cactoos.text.HexOf and org.cactoos.io.BytesOf – are no longer found. This change suggests that a breaking dependency update removed or relocated these classes.
2. In the client code, the problematic lines are the import statements for HexOf and BytesOf as well as the usage of these classes to convert a digest (byte array) into a hexadecimal string.
3. A potential fix is to remove the dependency on cactoos by replacing the functionality with a simple helper function that converts a byte array into its corresponding hexadecimal string. This approach adheres to the constraints (e.g., not changing method signatures) while resolving the compilation errors.
4. The changes required are:
   - Remove the import statements for org.cactoos.text.HexOf and org.cactoos.io.BytesOf.
   - Replace the expression new HexOf(new BytesOf(sha.digest())).asString() with a call to a new helper method (e.g., bytesToHex(sha.digest())) that implements the hexadecimal conversion.
   - Add the helper method (bytesToHex) into the class.
   
This patch addresses the dependency update issue by removing the reliance on the cactoos classes.
</code_analysis>

Below is the complete, fixed Java class:

```java
/*
 * The MIT License (MIT) Copyright (c) 2020-2021 artipie.com
 * https://github.com/artipie/docker-adapter/LICENSE.txt
 */
package com.artipie.docker.misc;

import com.artipie.asto.Content;
import com.artipie.docker.Digest;
import hu.akarnokd.rxjava2.interop.SingleInterop;
import io.reactivex.Completable;
import io.reactivex.Flowable;
import io.reactivex.Single;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.concurrent.CompletionStage;

/**
 * Digest from content.
 * @since 0.2
 */
public final class DigestFromContent {

    /**
     * Content.
     */
    private final Content content;

    /**
     * Ctor.
     * @param content Content publisher
     */
    public DigestFromContent(final Content content) {
        this.content = content;
    }

    /**
     * Calculates digest from content.
     * @return CompletionStage from digest
     */
    public CompletionStage<Digest> digest() {
        final MessageDigest sha;
        try {
            sha = MessageDigest.getInstance("SHA-256");
        } catch (final NoSuchAlgorithmException err) {
            throw new IllegalStateException("This runtime doesn't have SHA-256 algorithm", err);
        }
        return Flowable.fromPublisher(this.content)
            .flatMapCompletable(
                buf -> Completable.fromAction(
                    () -> {
                        buf.mark();
                        sha.update(buf);
                        buf.reset();
                    }
                )
            )
            .<Digest>andThen(
                Single.fromCallable(
                    () -> new Digest.Sha256(bytesToHex(sha.digest()))
                )
            )
            .to(SingleInterop.get()).toCompletableFuture();
    }

    /**
     * Converts a byte array into a hexadecimal string.
     * @param bytes The array of bytes.
     * @return The hexadecimal string representation.
     */
    private static String bytesToHex(final byte[] bytes) {
        char[] hexArray = "0123456789abcdef".toCharArray();
        char[] hexChars = new char[bytes.length * 2];
        for (int i = 0; i < bytes.length; i++) {
            int v = bytes[i] & 0xFF;
            hexChars[i * 2] = hexArray[v >>> 4];
            hexChars[i * 2 + 1] = hexArray[v & 0x0F];
        }
        return new String(hexChars);
    }
}
```
