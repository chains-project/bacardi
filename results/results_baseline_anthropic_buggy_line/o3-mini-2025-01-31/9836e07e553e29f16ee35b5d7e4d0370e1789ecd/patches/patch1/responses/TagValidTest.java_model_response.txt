<code_analysis>
1. The error message indicates that the constructor for org.hamcrest.core.StringContains now only accepts a single String argument. Previously, it accepted a boolean flag (to indicate case-sensitivity) and a String. The error occurs in the lines creating StringContains with two parameters.
2. In the client code, the two erroneous lines are:
   • new StringContains(true, "Invalid tag")
   • new StringContains(false, original)
   These lines are used inside an AllOf matcher to verify properties of the exception message.
3. To fix this, we can use the static factory method StringContains.containsString(String) for the positive match and use an explicit negation for the negative match. Specifically:
   • Replace new StringContains(true, "Invalid tag") with StringContains.containsString("Invalid tag").
   • Replace new StringContains(false, original) with new IsNot(StringContains.containsString(original)) (after importing org.hamcrest.core.IsNot) to assert that the exception message does not contain the original string.
4. These modifications align with the updated dependency version without changing function signatures or unrelated code.
</code_analysis>

```java
/*
 * The MIT License (MIT) Copyright (c) 2020-2022 artipie.com
 * https://github.com/artipie/docker-adapter/LICENSE.txt
 */
package com.artipie.docker;

import com.artipie.docker.error.InvalidTagNameException;
import java.util.Arrays;
import org.hamcrest.MatcherAssert;
import org.hamcrest.core.AllOf;
import org.hamcrest.core.IsEqual;
import org.hamcrest.core.IsNot;
import org.hamcrest.core.StringContains;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

/**
 * Tests for {@link Tag.Valid}.
 *
 * @since 0.2
 */
class TagValidTest {

    @ParameterizedTest
    @ValueSource(strings = {
        "latest",
        "1.0",
        "my-tag",
        "MY_TAG",
        "My.Tag.1",
        "_some_tag",
        // @checkstyle LineLengthCheck (1 line)
        "01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567"
    })
    void shouldGetValueWhenValid(final String original) {
        final Tag.Valid tag = new Tag.Valid(original);
        MatcherAssert.assertThat(tag.valid(), new IsEqual<>(true));
        MatcherAssert.assertThat(tag.value(), new IsEqual<>(original));
    }

    @ParameterizedTest
    @ValueSource(strings = {
        "",
        ".0",
        "*",
        "\u00ea",
        "-my-tag",
        // @checkstyle LineLengthCheck (1 line)
        "012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"
    })
    void shouldFailToGetValueWhenInvalid(final String original) {
        final Tag.Valid tag = new Tag.Valid(original);
        MatcherAssert.assertThat(tag.valid(), new IsEqual<>(false));
        final Throwable throwable = Assertions.assertThrows(
            InvalidTagNameException.class,
            tag::value
        );
        MatcherAssert.assertThat(
            throwable.getMessage(),
            new AllOf<>(
                Arrays.asList(
                    StringContains.containsString("Invalid tag"),
                    new IsNot(StringContains.containsString(original))
                )
            )
        );
    }
}
```
