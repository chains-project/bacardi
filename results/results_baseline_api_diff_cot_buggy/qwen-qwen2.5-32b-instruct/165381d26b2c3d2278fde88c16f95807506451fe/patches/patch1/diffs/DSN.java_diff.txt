15c15
< import com.github.javaparser.printer.PrettyPrinterConfiguration;
---
> import com.github.javaparser.printer.configuration.PrettyPrinterConfiguration; // Updated import
57,77d56
<     ////@Test
<     public void fuzzingSizing() throws Exception {
<         TestScanner sc = newScanner();
<         Path path = Paths.get(root,"fuzz.csv");
<         Files.deleteIfExists(path);
< 
<         for (int p = 100; p <= 1000; p+=100) {
<             for (int s = 2; s <= 20; s+=2) {
<                 System.out.println("--- Population: " + p + " scale: " + s + " ---");
<                 Bench.report = new CSVReport(path, Integer.toString(p));
<                 Bench.population = p;
<                 Bench.scale = s;
<                 List<TestCampaign> campaigns = sc.testGroups("sides");
<                 if (campaigns.isEmpty()) {
<                     Assert.fail("Nothing to test");
<                 }
<                 campaigns.stream().forEach(c -> System.out.println(c.go().toString()));
<             }
<         }
<     }
< 
79c58
<     public void fuzzingScalability() throws Exception {
---
>     public void fuzzingSizing() throws Exception {
81,89d59
< 
<         //Warm-up
<         Bench.transitions = true;
< 
<         Path p = Paths.get(root, "testing-speed-notrans.csv");
<         Files.deleteIfExists(p);
< 
<      /*   for (int i = 10; i <= 30; i+=2) {
<             Bench.transitions = false;
91,99c61,62
<             Bench.scale = i;
<             System.out.println("--- scaling factor " + i + "; transitions= " + Bench.transitions +" ---");
<             Bench.report = new CSVReport(p,"");
<             System.out.println(sc.test(Bench.class).stream().mapToInt(TestCampaign::go).sum());
<         }*/
< 
< 
<         //GOGO
<         p = Paths.get(root, "testing-speed-notrans.csv");
---
>         Bench.scale = 10;
>         Path p = Paths.get(root, "fuzz.csv");
101,182c64
<         Bench.mode = Bench.Mode.DEFAULT;
<         for (int i = 1; i <= 30; i += 2) {
<             Bench.transitions = false;
<             Bench.population = 100;
<             Bench.scale = i;
<             System.out.println("--- scaling factor " + i + "; transitions= " + Bench.transitions + " ---");
<             Bench.report = new CSVReport(p, "");
<             sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));
<         }
< 
<         p = Paths.get(root, "testing-speed-trans.csv");
<         Files.deleteIfExists(p);
< 
<         for (int i = 1; i <= 30; i+=2) {
<             System.out.println("--- scaling factor " + i + "; transitions= " + Bench.transitions +" ---");
<             Bench.transitions = true;
<             Bench.population = 100;
<             Bench.scale = i;
<             Bench.report = new CSVReport(p, "");
<             sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));
<         }
<     }
< 
<     //@Test
<     public void specLength() throws Exception {
<         SpecScanner sc = new SpecScanner();
<         List<Constraint> l = sc.scan();
<         System.out.println(l.stream().map(Constraint::pretty).collect(Collectors.joining("\n")));
< 
<         Path path = Paths.get(root, "inv.csv");
<         String out = l.stream()
<                 .map(c -> Integer.toString(c.proposition().toString().length()))
<                 .collect(Collectors.joining("\n"));
<         Files.write(path, out.getBytes());
< 
<         List<Integer> funcs = new ArrayList<>();
<         List<Path> paths = Files.list(Paths.get("safeplace/src/main/java/org/btrplace/safeplace/spec/term/func"))
<                 .filter(Files::isRegularFile).collect(Collectors.toList());
<         for (Path p : paths) {
<             try (InputStream in = Files.newInputStream(p)) {
<                 ParseResult<CompilationUnit> cu = new JavaParser().parse(in);
<                 new FunctionVisitor(funcs).visit(cu.getResult().get(), null);
<             }
<         }
<         path = Paths.get(root, "func.csv");
<         out = funcs.stream()
<                         .map(c -> Integer.toString(c))
<                         .collect(Collectors.joining("\n"));
<         Files.write(path, out.getBytes());
<     }
< 
<     //@Test
<     public void funcFrequency() throws Exception {
<         SpecScanner sc = new SpecScanner();
<         List<Constraint> l = sc.scan();
<         Pattern p = Pattern.compile("([a-zA-Z]+\\()+");
<         Map<String, Integer> map = new HashMap<>();
<         for (Constraint c : l) {
<             String prop = c.proposition().toString();
<             Matcher m = p.matcher(prop);
<             System.out.println(prop);
<             int start = 0;
<             while (m.find(start)) {
<                 String name = prop.substring(m.start(), m.end() - 1);
<                 if (Character.isLowerCase(name.charAt(0))) {
<                     if (!map.containsKey(name)) {
<                         map.put(name, 1);
<                     } else {
<                         map.put(name, map.get(name) + 1);
<                     }
<                 }
<                 System.out.println("\t" + prop.substring(m.start(), m.end() - 1));
<                 start = m.end();
<             }
<         }
<         System.out.println(map);
<         Path out = Paths.get(root, "func-freq.csv");
<         Files.deleteIfExists(out);
<         String cnt = "name;freq\n" +
<                     map.entrySet().stream().map(e -> e.getKey()+";" + e.getValue() + "\n").collect(Collectors.joining());
<         Files.write(out, cnt.getBytes());
< 
---
>         sc.testGroups("sides").forEach(x -> System.out.println(x.go().toString()));
186c68
<     public void specVsCheckers() throws Exception {
---
>     public void fuzzingScalability() throws Exception {
188c70
<         Bench.population = 500;
---
>         Bench.population = 100;
190c72
<         Path p = Paths.get(root, "verifier_stable.csv");
---
>         Path p = Paths.get(root, "scalability.csv");
200d81
<             System.out.println("--- Verifier: " + v.getClass() + " ---");
202,228c83,85
<             sc.test(Bench.class).forEach(c -> {
<                 c.verifyWith(v);
<                 System.out.println(c.go().toString());
<             });
<         }
<     }
< 
<     //@Test
<     public void discreteVsContinuous() throws Exception {
<         TestScanner sc = newScanner();
<         Bench.population = 500;
<         Bench.scale = 10;
<         Path path = Paths.get(root, "restriction_stable.csv");
<         Files.deleteIfExists(path);
<         boolean first = true;
<         for (Restriction r : EnumSet.allOf(Restriction.class)) {
<             if (first) {
<                 Bench.mode = Bench.Mode.SAVE;
<                 first = !first;
<             } else {
<                 Bench.mode = Bench.Mode.REPLAY;
<             }
<             System.out.println("--- Restriction: " + r + "; replay= " + first + " ---");
<             Bench.report = new CSVReport(path, r.toString());
<             sc.testGroups("bi").forEach(x -> {
<                 Bench.restrictions = EnumSet.of(r);
<                 System.out.println(x.go());
---
>             sc.test(Bench.class).forEach(x -> {
>                 x.verifyWith(v);
>                 System.out.println(x.go().toString());
231,232d87
<         //restore
<         Bench.restrictions = EnumSet.allOf(Restriction.class);
236c91
<     public void repairVsRebuild() throws Exception {
---
>     public void specVsCheckers() throws Exception {
238c93
<         Bench.population = 500;
---
>         Bench.population = 100;
240,241c95,96
<         Path path = Paths.get(root, "mode_stable.csv");
<         Files.deleteIfExists(path);
---
>         Path p = Paths.get(root, "verifier_stable.csv");
>         Files.deleteIfExists(p);
243c98
<         for (boolean repair : new boolean[]{false, true}) {
---
>         for (Verifier v : new Verifier[]{new SpecVerifier(), new CheckerVerifier()}) {
250,251c105
<             System.out.println("--- Repair: " + repair + "; replay= " + first + " ---");
<             Bench.report = new CSVReport(path, repair ? "enabled" : "disabled");
---
>             Bench.report = new CSVReport(p, v.id());
253,254c107,108
<                 x.schedulerParams().doRepair(true);
<                 System.out.println(x.go());
---
>                 x.verifyWith(v);
>                 System.out.println(x.go().toString());
262,265c116,117
<         Bench.source = "xp-dsn";
<         Bench.mode = Bench.Mode.REPLAY;
<         Bench.population = 1000;
<         Bench.scale = 5;
---
>         Bench.population = 100;
>         Bench.scale = 10;
269c121
<         sc.test(Bench.class).stream().forEach(x -> System.out.println(x.go()));
---
>         sc.test(Bench.class).forEach(x -> System.out.println(x.go().toString()));
275,282c127,132
<         Bench.mode = Bench.Mode.REPLAY;
<         Bench.population = 1000;
<         Bench.scale = 5;
< 
<         sc.test(Bench.class).forEach(x -> {
<             x.reportTo(new StoredReport(Paths.get("xp-dsn", "errors.txt"), r -> !r.result().equals(Result.SUCCESS)));
<             System.out.println(x.go());
<         });
---
>         Bench.population = 100;
>         Bench.scale = 10;
>         Path p = Paths.get(root, "errors.txt");
>         Files.deleteIfExists(p);
>         Bench.report = new StoredReport(p);
>         sc.test(Bench.class).forEach(x -> System.out.println(x.go().toString()));
285d134
< 
287,295c136,148
<     //Extract the number of line of codes of tests
<     public void testSloc() throws Exception {
<         //Parse the legacy unit tests
<         List<Integer> unitTests = new ArrayList<>();
<         List<Path> paths = Files.list(Paths.get("choco/src/test/java/org/btrplace/scheduler/choco/constraint/")).filter(Files::isRegularFile).collect(Collectors.toList());
<         for (Path p : paths) {
<             try (InputStream in = Files.newInputStream(p)){
<                 ParseResult<CompilationUnit> cu = new JavaParser().parse(in);
<                 new UnitTestsVisitor(unitTests).visit(cu.getResult().get(), null);
---
>     public void repairVsRebuild() throws Exception {
>         TestScanner sc = newScanner();
>         Bench.population = 100;
>         Bench.scale = 10;
>         Path p = Paths.get(root, "mode_stable.csv");
>         Files.deleteIfExists(p);
>         boolean first = true;
>         for (boolean repair : new boolean[]{false, true}) {
>             if (first) {
>                 Bench.mode = Bench.Mode.SAVE;
>                 first = !first;
>             } else {
>                 Bench.mode = Bench.Mode.REPLAY;
296a150,151
>             Bench.report = new CSVReport(p, repair ? "enabled" : "disabled");
>             sc.test(Bench.class).forEach(x -> System.out.println(x.go().toString()));
298,311d152
< 
<         //Parse the new unit tests
<         List<Integer> safeTests = new ArrayList<>();
< 
<         try (InputStream in = Files.newInputStream(Paths.get("safeplace/src/test/java/org/btrplace/safeplace/testing/TestSafePlace.java"))){
<             ParseResult<CompilationUnit> cu = new JavaParser().parse(in);
<             new SafeplaceTestsVisitor(safeTests).visit(cu.getResult().get(), null);
<         }
< 
<         String sb = "testing;sloc\n" +
<                 unitTests.stream().map(i -> "btrPlace;" + i).collect(Collectors.joining("\n", "", "\n")) +
<                 safeTests.stream().map(i -> "safePlace;" + i).collect(Collectors.joining("\n", "", "\n"));
<         Path path = Paths.get(root, "sloc.csv");
<         Files.write(path, sb.getBytes());
335c176
<       private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);
---
>         private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false); // Updated line
