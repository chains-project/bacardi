Due to an update of Library org.liquibase from version 3.4.2 to version 4.8.0, the code in file AddPrimaryKeyGeneratorMSSQL.java below is causing errors.

Here is the error message:
[ERROR] /liquibase-mssql/src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java:[12,22] cannot find symbol
  symbol:   class StringUtils
  location: package liquibase.util

[ERROR] /liquibase-mssql/src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java:[67,9] cannot find symbol
  symbol:   variable StringUtils
  location: class liquibase.ext.mssql.sqlgenerator.AddPrimaryKeyGeneratorMSSQL



Update the provided code to fix this error.

Focus only on updates that do not change the code's functionality and are related to the version update of the library.

You must reply in the following exact numbered format.

1. `The full updated code in a fenced code block` do not remove any code that you don't want to update keep it in the code block. Do not use "// ... (rest of the code remains unchanged)" in your response.
2. Explanation of the changes you made.

Provided code:

```
package liquibase.ext.mssql.sqlgenerator;

import liquibase.database.Database;
import liquibase.ext.mssql.database.MSSQLDatabase;
import liquibase.ext.mssql.statement.AddPrimaryKeyStatementMSSQL;
import liquibase.sql.Sql;
import liquibase.sql.UnparsedSql;
import liquibase.sqlgenerator.SqlGeneratorChain;
import liquibase.sqlgenerator.core.AddPrimaryKeyGenerator;
import liquibase.statement.core.AddPrimaryKeyStatement;
import liquibase.structure.core.Index;
import liquibase.util.StringUtils;

public class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {
  @Override
  public int getPriority() {
    return 15;
  }

  /**
   * Conditionally executes to extension's custom Primary Key SQL generation process if statement is the
   * AddPrimaryKeyStatementMSSQL implementation and the custom attribute (fillFactor) is set.
   *
   * Otherwise, defers to default liquibase implementation.
   *
   * @param statement
   * @param database
   * @param sqlGeneratorChain
   * @return
   */
  @Override
  public Sql[] generateSql(AddPrimaryKeyStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {
    if (statement instanceof AddPrimaryKeyStatementMSSQL && ((AddPrimaryKeyStatementMSSQL) statement).getFillFactor() != null) {
      return generateMSSQLSql((AddPrimaryKeyStatementMSSQL)statement, database, sqlGeneratorChain);
    }

    return super.generateSql(statement, database, sqlGeneratorChain);
  }

  /**
   * The extension's implementation is essentially a copy/paste of the default implementation, with the following changes:
   *
   * 1) Removed other database platform specific logic other than MSSQL (purely to simplify)
   *
   * 2) Added support for setting fillFactor
   *
   * @param statement
   * @param database
   * @param sqlGeneratorChain
   * @return
   */
  private Sql[] generateMSSQLSql(AddPrimaryKeyStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {
    String sql;
    if (statement.getConstraintName() == null) {
      sql = "ALTER TABLE " + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + " ADD PRIMARY KEY (" + database.escapeColumnNameList(statement.getColumnNames()) + ")";
    } else {
      sql = "ALTER TABLE " + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + " ADD CONSTRAINT " + database.escapeConstraintName(statement.getConstraintName())+" PRIMARY KEY";
      if (!statement.isClustered()) {
        sql += " NONCLUSTERED";
      }
      sql += " (" + database.escapeColumnNameList(statement.getColumnNames()) + ")";
    }

    // the only new feature being added is support for fillFactor
    sql += " WITH (FILLFACTOR = " + statement.getFillFactor() + ")";

    if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {
      sql += " ON "+statement.getTablespace();
    }

    if (statement.getForIndexName() != null) {
      sql += " USING INDEX "+database.escapeObjectName(statement.getForIndexCatalogName(), statement.getForIndexSchemaName(), statement.getForIndexName(), Index.class);
    }

    return new Sql[] {
        new UnparsedSql(sql, getAffectedPrimaryKey(statement))
    };
  }

  @Override
  public boolean supports(AddPrimaryKeyStatement statement, Database database) {
    return database instanceof MSSQLDatabase;
  }

}


```

Your Response: