<code_analysis>
1. The error message indicates that the constructor for StringContains is now defined to accept only a single String argument. The original code is attempting to pass two arguments (a boolean and a String) in two places:
   - new StringContains(true, "Invalid tag")
   - new StringContains(false, original)
2. Reviewing the test code, these two matchers are used within an AllOf matcher to check the error message. It appears the intention was:
   - To verify that the error message contains the substring "Invalid tag".
   - To verify that the error message does not contain the original invalid tag.
3. In the updated dependency version, the StringContains constructor no longer accepts the boolean flag. To replicate the original logic:
   - For the first matcher, simply check for the presence of "Invalid tag" by creating new StringContains("Invalid tag").
   - For the second matcher, to check that the original string is not present, wrap new StringContains(original) inside a not() matcher (using CoreMatchers.not).
4. The necessary modifications are:
   - Remove the boolean arguments from both constructor calls.
   - Replace the second matcher with CoreMatchers.not(new StringContains(original)) to assert the absence of the original substring.
   - Add the required import for org.hamcrest.CoreMatchers.
</code_analysis>

```java
package com.artipie.docker;

import com.artipie.docker.error.InvalidTagNameException;
import java.util.Arrays;
import org.hamcrest.MatcherAssert;
import org.hamcrest.core.AllOf;
import org.hamcrest.core.IsEqual;
import org.hamcrest.core.StringContains;
import org.hamcrest.CoreMatchers;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

/**
 * Tests for {@link Tag.Valid}.
 *
 * @since 0.2
 */
class TagValidTest {

    @ParameterizedTest
    @ValueSource(strings = {
        "latest",
        "1.0",
        "my-tag",
        "MY_TAG",
        "My.Tag.1",
        "_some_tag",
        //@checkstyle LineLengthCheck (1 line)
        "01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567"
    })
    void shouldGetValueWhenValid(final String original) {
        final Tag.Valid tag = new Tag.Valid(original);
        MatcherAssert.assertThat(tag.valid(), new IsEqual<>(true));
        MatcherAssert.assertThat(tag.value(), new IsEqual<>(original));
    }

    @ParameterizedTest
    @ValueSource(strings = {
        "",
        ".0",
        "*",
        "\u00ea",
        "-my-tag",
        //@checkstyle LineLengthCheck (1 line)
        "012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"
    })
    void shouldFailToGetValueWhenInvalid(final String original) {
        final Tag.Valid tag = new Tag.Valid(original);
        MatcherAssert.assertThat(tag.valid(), new IsEqual<>(false));
        final Throwable throwable = Assertions.assertThrows(
            InvalidTagNameException.class,
            tag::value
        );
        MatcherAssert.assertThat(
            throwable.getMessage(),
            new AllOf<>(
                Arrays.asList(
                    new StringContains("Invalid tag"),
                    CoreMatchers.not(new StringContains(original))
                )
            )
        );
    }
}
```
