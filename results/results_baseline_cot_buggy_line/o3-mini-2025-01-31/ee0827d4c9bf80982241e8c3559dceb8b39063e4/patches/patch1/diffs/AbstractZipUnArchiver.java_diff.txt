1,16d0
< /**
<  *
<  * Copyright 2004 The Apache Software Foundation
<  *
<  * Licensed under the Apache License, Version 2.0 (the "License");
<  * you may not use this file except in compliance with the License.
<  * You may obtain a copy of the License at
<  *
<  * http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing, software
<  * distributed under the License is distributed on an "AS IS" BASIS,
<  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<  * See the License for the specific language governing permissions and
<  * limitations under the License.
<  */
28d11
< import org.apache.commons.io.input.BoundedInputStream;
34,38c17
< /**
<  * @author <a href="mailto:evenisse@codehaus.org">Emmanuel Venisse</a>
<  */
< public abstract class AbstractZipUnArchiver
<     extends AbstractUnArchiver
---
> public abstract class AbstractZipUnArchiver extends AbstractUnArchiver
203a183
>                         // Use our own minimal implementation of BoundedInputStream.
211c191,192
<                         remainingSpace -= cis.getByteCount();
---
>                         // Replace getByteCount() with getCount() which is available with the updated dependency.
>                         remainingSpace -= cis.getCount();
226a208,271
>     /**
>      * Minimal implementation of BoundedInputStream to limit the number of bytes read.
>      */
>     private static class BoundedInputStream extends InputStream {
> 
>         private final InputStream in;
>         private long remaining;
> 
>         public BoundedInputStream(InputStream in, long size) {
>             this.in = in;
>             this.remaining = size;
>         }
> 
>         @Override
>         public int read() throws IOException {
>             if (remaining <= 0) {
>                 return -1;
>             }
>             int result = in.read();
>             if (result != -1) {
>                 remaining--;
>             }
>             return result;
>         }
> 
>         @Override
>         public int read(byte[] b, int off, int len) throws IOException {
>             if (remaining <= 0) {
>                 return -1;
>             }
>             if (len > remaining) {
>                 len = (int) remaining;
>             }
>             int count = in.read(b, off, len);
>             if (count > 0) {
>                 remaining -= count;
>             }
>             return count;
>         }
> 
>         @Override
>         public long skip(long n) throws IOException {
>             if (remaining <= 0) {
>                 return 0;
>             }
>             if (n > remaining) {
>                 n = remaining;
>             }
>             long skipped = in.skip(n);
>             remaining -= skipped;
>             return skipped;
>         }
> 
>         @Override
>         public int available() throws IOException {
>             int available = in.available();
>             return (int)Math.min(available, remaining);
>         }
> 
>         @Override
>         public void close() throws IOException {
>             in.close();
>         }
>     }
