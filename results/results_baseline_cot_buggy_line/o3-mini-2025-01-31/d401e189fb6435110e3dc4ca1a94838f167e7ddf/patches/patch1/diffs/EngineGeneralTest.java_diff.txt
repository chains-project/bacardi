1,15d0
< /*
<  * Copyright 2014 Feedzai
<  *
<  * Licensed under the Apache License, Version 2.0 (the "License");
<  * you may not use this file except in compliance with the License.
<  * You may obtain a copy of the License at
<  *
<  *     http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing, software
<  * distributed under the License is distributed on an "AS IS" BASIS,
<  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<  * See the License for the specific language governing permissions and
<  * limitations under the License.
<  */
19a5
> import ch.qos.logback.classic.LoggerContext;  // Added import for LoggerContext
25a12,14
> import com.feedzai.commons.sql.abstraction.ddl.CLOB;
> import com.feedzai.commons.sql.abstraction.ddl.BLOB;
> import com.feedzai.commons.sql.abstraction.ddl.DbFk;
68d56
< 
85d72
< 
158,161d144
< /**
<  * @author Rui Vilao (rui.vilao@feedzai.com)
<  * @since 2.0.0
<  */
165d147
< 
181c163,165
<         ((Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)).setLevel(Level.TRACE);
---
>         // Use LoggerContext from Logback to properly set the log level
>         LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
>         loggerContext.getLogger(Logger.ROOT_LOGGER_NAME).setLevel(Level.TRACE);
408,409c392
<         EntityEntry entry = entry().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS")
<                 .build();
---
>         EntityEntry entry = entry().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS").build();
444,445c427
<         EntityEntry entry = entry().set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS")
<                 .build();
---
>         EntityEntry entry = entry().set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS").build();
480,481c462
<         EntityEntry entry = entry().set("COL1", 1).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS")
<                 .build();
---
>         EntityEntry entry = entry().set("COL1", 1).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS").build();
530,537d510
<     /**
<      * Tests that an iterator created in a try-with-resources' resource specification header is automatically closed
<      * once the block is exited from.
<      *
<      * @throws Exception If an unexpected error occurs.
<      *
<      * @since 2.1.12
<      */
575,576c548
<             EntityEntry entry = entry().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS")
<                     .build();
---
>             EntityEntry entry = entry().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS").build();
580,581c552
<             entry = entry().set("COL1", 3).set("COL2", true).set("COL3", 3D).set("COL4", 4L).set("COL5", "OLA")
<                     .build();
---
>             entry = entry().set("COL1", 3).set("COL2", true).set("COL3", 3D).set("COL4", 4L).set("COL5", "OLA").build();
634,635c605
<         EntityEntry entry = entry().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS")
<                 .build();
---
>         EntityEntry entry = entry().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS").build();
639,640c609
<         entry = entry().set("COL1", 3).set("COL2", true).set("COL3", 3D).set("COL4", 4L).set("COL5", "OLA")
<                 .build();
---
>         entry = entry().set("COL1", 3).set("COL2", true).set("COL3", 3D).set("COL4", 4L).set("COL5", "OLA").build();
684,753d652
<     /**
<      * Tests that on a rollback situation, the prepared statement batches are cleared.
<      *
<      * The steps performed on this test are:
<      * <ol>
<      *     <li>Add batch to transaction and purposely fail to flush</li>
<      *     <li>Ensure the existence of the Exception and rollback transaction</li>
<      *     <li>Flush again successfully and ensure that the DB table doesn't have any rows</li>
<      * </ol>
<      *
<      * This is a regression test.
<      *
<      * @throws DatabaseEngineException If there is a problem on {@link DatabaseEngine} operations.
<      * @since 2.1.12
<      */
<     @Test
<     public void batchInsertRollback() throws DatabaseEngineException {
<         final CountDownLatch latch = new CountDownLatch(1);
< 
<         final DbEntity entity = dbEntity()
<                 .name("TEST")
<                 .addColumn("COL1", INT)
<                 .build();
< 
<         new MockUp<AbstractDatabaseEngine>() {
<             @Mock
<             public synchronized void flush(final Invocation invocation) throws DatabaseEngineException {
<                 if (latch.getCount() == 1) {
<                     throw new DatabaseEngineException("");
<                 }
<                 invocation.proceed();
<             }
<         };
< 
<         DatabaseEngineException expectedException = null;
< 
<         engine.addEntity(entity);
<         engine.beginTransaction();
< 
<         try {
<             final EntityEntry entry = entry().set("COL1", 1).build();
< 
<             engine.addBatch("TEST", entry);
<             engine.flush();
<             fail("Was expecting the flush operation to fail");
<         } catch (final DatabaseEngineException e) {
<             expectedException = e;
<         } finally {
<             if (engine.isTransactionActive()) {
<                 engine.rollback();
<             }
<         }
< 
<         // Ensure we had an exception and therefore we didn't insert anything on the DB and that we cleared the batches.
<         assertNotNull("DB returned exception when flushing", expectedException);
< 
<         latch.countDown();
<         engine.beginTransaction();
<         engine.flush();
<         engine.commit();
< 
<         final List<Map<String, ResultColumn>> query = engine.query(select(all())
<                                                                            .from(table("TEST"))
<                                                                            .orderby(column("COL1").asc()));
< 
<         // Previously, we rolled back the transaction; now we are trying the flush an empty transaction.
<         // Therefore, we shouldn't have any rows on the table.
<         assertEquals("There are no rows on table TEST", 0, query.size());
<     }
< 
1448,1453d1346
<     /**
<      * Tests that when persisting an entity in table that does not contain any auto generated values, the
<      * {@link DatabaseEngine#persist(String, EntityEntry)} method returns {@code null}.
<      *
<      * @throws DatabaseEngineException If any error occurs.
<      */
1460d1352
<             // Set the two columns as fields of primary key, so they belong to the generated keys.
1476,1479d1367
<     /**
<      * Tests that when trying to add {@link DbEntity} with multiple columns with auto incremented values, the
<      * {@link DatabaseEngine#addEntity(DbEntity)} method throws a {@link DatabaseEngineException}.
<      */
1664,1665d1551
<     // unimplemented in CockroachDB: views do not currently support * expressions
<     // https://github.com/cockroachdb/cockroach/issues/10028
1678,1679d1563
<     // unimplemented in CockroachDB: views do not currently support * expressions
<     // https://github.com/cockroachdb/cockroach/issues/10028
1721,1725d1604
<     /**
<      * Tests that the {@link SqlBuilder#in(Expression, Expression) IN} clause with a value filters a row correctly.
<      *
<      * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
<      */
1731,1735d1609
<     /**
<      * Tests that the {@link SqlBuilder#in(Expression, Expression) IN} clause with SELECT filters a row correctly.
<      *
<      * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
<      */
1744,1752d1617
<     /**
<      * Tests that the {@link SqlBuilder#in(Expression, Expression) IN} clause with values filters a row correctly,
<      * when many values are provided.
<      * <p>
<      * This is a regression test for Oracle, which only supports up to 1000 values in IN clauses; the test uses
<      * 20000 values.
<      *
<      * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
<      */
1762,1767d1626
<     /**
<      * Tests that the {@link SqlBuilder#notIn(Expression, Expression) (Expression, Expression) negated IN} clause
<      * with a value filters a row correctly.
<      *
<      * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
<      */
1773,1777d1631
<     /**
<      * Tests that the {@link SqlBuilder#notIn(Expression, Expression) negated IN} clause with SELECT filters a row correctly.
<      *
<      * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
<      */
1786,1794d1639
<     /**
<      * Tests that the {@link SqlBuilder#notIn(Expression, Expression) negated IN} clause with a value filters a row
<      * correctly, when many values are provided.
<      * <p>
<      * This is a regression test for Oracle, which only supports up to 1000 values in IN clauses; the test uses
<      * 20000 values.
<      *
<      * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
<      */
1804,1819d1648
<     /**
<      * Common code to run IN clause tests.
<      * <p>
<      * This creates 2 entries in the database:
<      * <table>
<      *     <tr><td>COL1</td><td>COL5</td></tr>
<      *     <tr><td>1</td><td>s1</td></tr>
<      *     <tr><td>2</td><td>s2</td></tr>
<      * </table>
<      * <p>
<      * The verifications expect the provided {@code whereInExpression} to filter the entries such that only the first
<      * one is returned.
<      *
<      * @param whereInExpression The {@link Expression} to use in the WHERE clause of the query.
<      * @throws DatabaseEngineException If a DB error occurs.
<      */
1946,1947d1774
< 
< 
1989d1815
<         // test CAST when writing values
1997d1822
<         // test CAST when reading values
2013,2019d1837
<         /*
<          Until now the test only really checks if the CAST doesn't cause any errors because
<           - when writing values into the DB it automatically casts into the column data type
<           - when reading values from the DB, the test reads the results from the ResultColumn as the desired type
<          Even if we used a function, it is likely the DB would try to cast the parameters to the expected type.
<          To effectively test if CAST works, we need to check if DB sorting considers the column a string or a number.
<          */
2038,2042d1855
<     /**
<      * Check if exception is thrown when trying to cast for an unsupported type.
<      *
<      * @throws DatabaseEngineException If something goes wrong executing the query.
<      */
2269,2275d2081
<     /**
<      * Runs a concat query on the test dataset, given a delimiter.
<      *
<      * @param delimiter the delimiter used in concat.
<      * @return the result set.
<      * @throws DatabaseEngineException if an issue when querying arises.
<      */
2307,2322d2112
<     /**
<      * Reproduces an issue when using CASE ... WHEN expressions in SqlServer and MySql.
<      * <p>
<      * Since we don't have the type information for a column that is generated from the result of a WHEN expression,
<      * we need to rely on the user calling one of the ResultColumn.toXXX methods to understand what the user is
<      * expecting. In the case of ResultColumn.toBoolean(), we're first checking if the result is of boolean type,
<      * as happens normally when the driver knows that the column is of type boolean, but then we also try to parse the
<      * underlying database boolean representation. This is necessary because in WHEN expressions, the driver doesn't
<      * know the expected return type.
<      * <p>
<      * I also tried to fix this using {@code cast(1 as BIT)}, which seemed more appropriate because we would be hinting
<      * the driver about the type, but it's not possible to follow this approach in MySql because we cannot cast to
<      * tinyint(1), which is the native type for booleans in MySql.
<      *
<      * @throws DatabaseEngineException propagate
<      */
2480d2269
<         // If it crashes, the test will fail.
2668d2456
<         // check to see if TEST has changed
2675d2462
<         //check if only the 1st and the 5th were changed.
2888d2674
<         // 10 mb
2999d2784
<         // as the fields were removed the entity mapping ignores the fields.
3004d2788
< 
3024d2807
< 
3029d2811
<         // First drop-create
3046d2827
<         // Clone the connection with the create now.
3061,3062d2841
<         // as the fields were removed the entity mapping ignores the fields.
<         System.out.println("> " + engine2.getMetadata("TEST"));
3086a2866
>         engine2.close();
3089,3092d2868
<     /**
<      * Tests that {@link AbstractDatabaseEngine#updateEntity(DbEntity)} with a "none" schema policy
<      * still creates the in-memory {@link MappedEntity} with the prepared statements for the entities.
<      */
3133d2908
<         // Persist the entry and make sure it was successful
3148,3151d2922
<     /**
<      * Tests that {@link AbstractDatabaseEngine#updateEntity(DbEntity)} with a "none" schema policy
<      * doesn't execute DDL.
<      */
3174c2945
<             // Should fail because because updateEntity with schema policy NONE doesn't execute DDL
---
>             // Expected exception.
3291d3061
< 
3330d3099
< 
3392d3160
< 
3410d3177
< 
3482d3248
< 
3493d3258
< 
3531d3295
<         // Drop tables for sanity.
3534d3297
<         // Create the "old" table.
3543d3305
<         // Rename it
3547d3308
<         // Check whether the schema matches
3552d3312
<         // Check the data
3561,3565d3320
<     /**
<      * Drops a list of tables silently (i.e. if it fails, it will just keep on).
<      *
<      * @param tables The tables that we want to drop.
<      */
3615d3369
< 
3640c3394,3395
<         engine.persist("TEST", entry().set("COL1", 1).set("COL2", true).build());
---
>         engine.persist("TEST", entry().set("COL1", 1).set("COL2", true)
>                 .build());
3670,3674d3424
<     /**
<      * Creates a {@link DbEntity} with 5 columns to be used in the tests.
<      *
<      * @throws DatabaseEngineException If something goes wrong creating the entity.
<      */
3688,3692d3437
<     /**
<      * Creates a {@link DbEntity} with 5 columns being the first the primary key to be used in the tests.
<      *
<      * @throws DatabaseEngineException If something goes wrong creating the entity.
<      */
4131,4137d3875
<     /**
<      * Tests that creating a {@link DatabaseEngine} using try-with-resources will close the engine
<      * (and thus the underlying connection to the database) once the block is exited from.
<      *
<      * @throws Exception if something goes wrong while checking if the connection of the engine is closed.
<      * @since 2.1.12
<      */
4162,4171d3899
<     /**
<      * Test that closing a database engine a 'create-drop' policy with multiple entities closes all insert statements
<      * associated with each entity, regardless of the schema policy used.
<      *
<      * Each entity is associated with 3 prepared statements. This test ensures that 3 PSs per entity are closed.
<      *
<      * @throws DatabaseEngineException  If something goes wrong while adding an entity to the engine.
<      * @throws DatabaseFactoryException If the database engine class specified in the properties does not exist.
<      * @since 2.1.13
<      */
4176d3903
<         // Force the schema policy to be 'create-drop'
4183d3909
<         // Force invocation counting to start here
4194,4199d3919
<     /**
<      * Assesses whether the current row count is incremented if the .next()/.nextResult()
<      * methods are called in the iterator.
<      *
<      * @throws DatabaseEngineException If a database access error happens.
<      */
4204d3923
<         // Create 4 entries
4213d3931
<         // If the .next() method is called once then the current row count should be updated to 1
4218,4219d3935
<         // If for the same iterator the .nextResult() method is called 3 additional
<         // times then the current row count should be updated to 4
4227,4233d3942
<     /**
<      * Tests that a {@link com.feedzai.commons.sql.abstraction.dml.K constant expression} with an enum value behaves
<      * as if the enum is a string (obtained from {@link Enum#name()}, both when persisting an entry and when using
<      * the enum value for filtering in a WHERE clause.
<      *
<      * @throws DatabaseEngineException If something goes wrong creating the test entity or persisting entries.
<      */
4238d3946
<         // should fail here if enum is not supported, or it will just put garbage, which will be detected later
4258,4268d3965
<     /**
<      * Tests that when inserting duplicated entries in a table the right exception is returned.
<      *
<      * The steps performed on this test are:
<      * <ol>
<      *     <li>Add duplicated entries in a transaction and fail to persist</li>
<      *     <li>Ensure the exception is a {@link DatabaseEngineUniqueConstraintViolationException}</li>
<      * </ol>
<      *
<      * @throws DatabaseEngineException If there is a problem on {@link DatabaseEngine} operations.
<      */
4280d3976
<         // Add the same entry twice (repeated value for COL1, id)
4290,4300d3985
<     /**
<      * Tests that on a duplicated batch entry situation the right exception is returned.
<      *
<      * The steps performed on this test are:
<      * <ol>
<      *     <li>Add duplicated batch entries to transaction and fail to flush</li>
<      *     <li>Ensure the exception is a {@link DatabaseEngineUniqueConstraintViolationException}</li>
<      * </ol>
<      *
<      * @throws DatabaseEngineException If there is a problem on {@link DatabaseEngine} operations.
<      */
4312d3996
<         // Add the same entry twice (repeated value for COL1, id)
4316d3999
<         // Flush the duplicated entries and check the exception
4325,4327d4007
<     /**
<      * An enum for tests.
<      */
