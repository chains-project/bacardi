<code_analysis>
1. Examine the error message:
   - The error message indicates that the packages `org.cactoos.io` and `org.cactoos.text` do not exist, which implies that the dependencies for these packages might have been removed or the package structure has changed in the newer version of the library.
   - The specific issue is with the `HexOf` class, which is not found in the updated library.

2. Review the client code:
   - The client code uses `HexOf` from `org.cactoos.text` to convert byte arrays to hex strings. This is a critical part of the digest calculation.
   - Since `BytesOf` is also from `org.cactoos.io`, we need to find alternatives for both of these classes.

3. Consider potential fixes that adhere to the following constraints:
   - We need to replace the functionality of `BytesOf` and `HexOf` with equivalent logic that does not rely on the `org.cactoos` library.
   - We can use native Java libraries to achieve the same functionality for converting a byte array to a hexadecimal string.

4. Plan the necessary changes to fix the issue:
   - Replace the `BytesOf` class with a simple conversion to a byte array.
   - Replace the `HexOf` class with a method that converts a byte array to a hexadecimal string.
   - Ensure that the code remains logically intact and does not change method signatures or existing functionality.

</code_analysis>

```java
/*
 * The MIT License (MIT) Copyright (c) 2020-2021 artipie.com
 * https://github.com/artipie/docker-adapter/LICENSE.txt
 */
package com.artipie.docker.misc;

import com.artipie.asto.Remaining;
import com.artipie.asto.ext.Digests;
import com.artipie.docker.Digest;
import io.reactivex.Flowable;
import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicReference;
import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;

/**
 * {@link Flowable} that calculates digest of origin {@link Publisher} bytes when they pass by.
 *
 * @since 0.12
 */
public final class DigestedFlowable extends Flowable<ByteBuffer> {

    /**
     * Origin publisher.
     */
    private final Publisher<ByteBuffer> origin;

    /**
     * Calculated digest.
     */
    private final AtomicReference<Digest> dig;

    /**
     * Ctor.
     *
     * @param origin Origin publisher.
     */
    public DigestedFlowable(final Publisher<ByteBuffer> origin) {
        this.dig = new AtomicReference<>();
        this.origin = origin;
    }

    @Override
    public void subscribeActual(final Subscriber<? super ByteBuffer> subscriber) {
        final MessageDigest sha = Digests.SHA256.get();
        Flowable.fromPublisher(this.origin).map(
            buf -> {
                sha.update(new Remaining(buf, true).bytes());
                return buf;
            }
        ).doOnComplete(
            () -> this.dig.set(
                new Digest.Sha256(bytesToHex(sha.digest()))
            )
        ).subscribe(subscriber);
    }

    /**
     * Convert byte array to hex string.
     *
     * @param bytes Byte array.
     * @return Hexadecimal string.
     */
    private String bytesToHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder();
        for (byte b : bytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
        return hexString.toString();
    }

    /**
     * Calculated digest.
     *
     * @return Digest.
     */
    public Digest digest() {
        return Objects.requireNonNull(this.dig.get(), "Digest is not yet calculated.");
    }
}
``` 

In this updated code, I have replaced the dependency on `HexOf` and `BytesOf` with a custom method `bytesToHex` that converts a byte array to a hex string, thus resolving the compilation errors caused by the missing imports. The functionality and structure of the class remain unchanged.
