```java
package micycle.pgs;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.math3.ml.clustering.Clusterable;
import org.tinspin.index.kdtree.KDTree;

import processing.core.PVector;

/**
 * Generation of random sets of 2D points having a variety of different
 * distributions and constraints (and associated functions).
 * 
 * @author Michael Carleton
 * @since 1.2.0
 *
 */
public final class PGS_PointSet {

    private static final float SQRT_3 = (float) Math.sqrt(3);
    /** Golden angle (in radians) */
    private static final float GOLDEN_ANGLE = (float) (Math.PI * (3 - Math.sqrt(5)));

    private PGS_PointSet() {
    }

    /**
     * Returns a filtered copy of the input, containing no points that are within
     * the <code>distanceTolerance</code> of each other.
     * <p>
     * This method can be used to convert a random point set into a blue-noise-like
     * (poisson) point set.
     * 
     * @param points            list of points to filter
     * @param distanceTolerance a point that is within this distance of a previously
     *                          included point is not included in the output
     * @return
     */
    public static List<PVector> prunePointsWithinDistance(List<PVector> points, double distanceTolerance) {
        final KDTree<PVector> tree = KDTree.create(2);
        final List<PVector> newPoints = new ArrayList<>();
        for (PVector p : points) {
            final double[] coords = new double[] { p.x, p.y };
            // Updated the query from query1NN to queryNearest
            if (tree.size() == 0 || tree.queryNearest(coords, 1).isEmpty() || 
                tree.queryNearest(coords, 1).get(0).dist() > distanceTolerance) {
                tree.insert(coords, p);
                newPoints.add(p);
            }
        }
        return newPoints;
    }

    private static class CPVector implements Clusterable {
        final PVector p;
        final double[] point;

        CPVector(PVector p) {
            this.p = p;
            point = new double[] { p.x, p.y };
        }

        @Override
        public double[] getPoint() {
            return point;
        }
    }

}
``` 

### Explanation of Changes:
- The method `query1NN` is replaced with `queryNearest`, which is the updated method based on the new version of the KDTree dependency. This method returns a list of nearest neighbors, so we check if the list is empty and get the distance from the first element if it's not empty.
- The rest of the code remains unchanged to adhere to the requirements, ensuring that the functionality is preserved while resolving the compilation error.
