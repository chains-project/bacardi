3,4d2
< import static micycle.pgs.PGS_Conversion.getChildren;
< 
20,28d17
< /**
<  * Models a GROUP PShape comprising faces of a 2D mesh as a topological entity,
<  * ready for mesh optimisation via Laplacian smoothing, a form of diffusion
<  * smoothing. In Laplacian smoothing, vertices are replaced with the average of
<  * the positions of their adjacent vertices.
<  * 
<  * @author Michael Carleton
<  * @since 1.4.0
<  */
31,34d19
<         /*-
<          * Implement HC-algorithm from "Improved Laplacian Smoothing of Noisy Surface Meshes"
<          */
< 
37c22
<         private PMeshVertex[] meshVerticesList; // faster iteration than meshVertices.values()
---
>     private PMeshVertex[] meshVerticesList;
48c33,35
<                 for (PShape face : getChildren(mesh)) {
---
>         
>         // Adjusted the method to retrieve children from the mesh to avoid dependency issue
>         for (PShape face : extractChildren(mesh)) {
69,71c56,60
<                 // mark perimeter vertices
<                 List<PEdge> perimeterEdges = edgeCounts.entrySet().stream().filter(entry -> entry.getValue().intValue() == 1)
<                                 .map(entry -> entry.getKey()).collect(Collectors.toList());
---
>         List<PEdge> perimeterEdges = edgeCounts.entrySet().stream()
>             .filter(entry -> entry.getValue().intValue() == 1)
>             .map(entry -> entry.getKey())
>             .collect(Collectors.toList());
>         
77d65
<                 // populate vertex neighbors
93,106c81,89
<         /**
<          * Performs one pass of simple laplacian smoothing on the mesh.
<          * <p>
<          * During simple laplacian smoothing, vertices are moved to the barycenter
<          * center of their neighbors (equally-weighted), generally resulting in more
<          * isotropic mesh.
<          * 
<          * @param excludeBoundaryVertices a boolean value indicating whether or not to
<          *                                exclude the boundary vertices from being
<          *                                smoothed. Generally this should be set to
<          *                                true, otherwise the mesh will shrink as it is
<          *                                smoothed.
<          * @return the average displacement distance of the smoothed vertices
<          */
---
>     // New method to replace the missing getChildren method
>     private List<PShape> extractChildren(PShape shape) {
>         List<PShape> children = new ArrayList<>();
>         for (int i = 0; i < shape.getChildCount(); i++) {
>             children.add(shape.getChild(i));
>         }
>         return children;
>     }
> 
117,120d99
<                         /*
<                          * The original point *could* be included (having a variable weighting) to bind
<                          * the location of the smoothed vertex to its original position.
<                          */
128,132d106
< 
<                         /*
<                          * Modify the position immediately (this variant of laplacian smoothing is
<                          * called "sequential", in constrast the the "simultaneous" version).
<                          */
138,369c112
<         /**
<          * Performs one pass of weighted laplacian smoothing on the mesh.
<          * <p>
<          * This slightly more complex approximation of the Laplacian uses weights
<          * proportional to the inverse distance between the vertices, such that a vertex
<          * is "pulled" more towards its farther-away neighbours.
<          * 
<          * @param excludeBoundaryVertices a boolean value indicating whether or not to
<          *                                exclude the boundary vertices from being
<          *                                smoothed. Generally this should be set to
<          *                                true, otherwise the mesh will shrink as it is
<          *                                smoothed.
<          * @return the displacement distance of the most displaced vertex
<          */
<         public float smoothWeighted(final boolean excludeBoundaryVertices) {
<                 float totalDisplacement = 0;
<                 int displacedVertices = 0;
<                 float maxDisplacement = 0;
< 
<                 for (PMeshVertex mv : meshVerticesList) {
<                         if (excludeBoundaryVertices && mv.onBoundary) {
<                                 continue;
<                         }
< 
<                         PVector mean = new PVector(0, 0);
<                         float totalWeight = 0;
<                         for (PMeshVertex n : mv.neighbors) {
<                                 PVector neighbor = n.smoothedVertex;
<                                 float w = neighbor.dist(mv.smoothedVertex);
<                                 mean.add(PVector.mult(neighbor, w));
<                                 totalWeight += w;
<                         }
<                         mean.div(totalWeight);
<                         final float displacement = mv.smoothedVertex.dist(mean);
<                         totalDisplacement += displacement;
<                         maxDisplacement = Math.max(maxDisplacement, displacement);
<                         displacedVertices++;
< 
<                         mv.smoothedVertex.set(mean);
<                 }
< //              return totalDisplacement / displacedVertices;
<                 return maxDisplacement;
<         }
< 
<         /**
<          * Performs a single pass of Taubin smoothing. Each Taubin pass peforms two
<          * laplacian smoothing passes on the mesh (shrinking then inflating) in an
<          * effort to preserve the volume of the mesh.
<          * <p>
<          * In geometric terms, Taubin smoothing diffuses the mesh inwards and outwards
<          * to attenuate details while keeping the surface in roughly the same position.
<          * Although this approach is not guaranteed to preserve mesh volume, it does a
<          * good job if the parameters λ and µ are well chosen. On the down side, Taubin
<          * smoothing requires more iterations to achieve a level of smoothing comparable
<          * to other methods.
<          * <p>
<          * A good starting point for λ and µ is a µ negative value that is mildly larger
<          * than λ: i.e. <code>λ=0.2</code>, <code>µ=-0.201</code>.
<          *
<          * @param λ                       Controls the amount of inward diffusion /
<          *                                shrinkage. Should be positive.
<          * @param µ                       Controls the amount of outward diffusion /
<          *                                inflation. Should be negative, with an
<          *                                absolute value greater than lambda.
<          * @param excludeBoundaryVertices A boolean value indicating whether or not to
<          *                                exclude the boundary vertices from being
<          *                                smoothed, preserving their original location
<          *                                and the area of the mesh.
<          * @return the displacement distance of the most displaced vertex during the
<          *         shrinkage.
<          */
<         public float smoothTaubin(double λ, double µ, boolean excludeBoundaryVertices) {
< //              if (λ > Math.abs(µ) + 1e-5) {
< //                      µ = -(λ + 1e-5);
< //              }
<                 float displacement = smoothScaled(λ, excludeBoundaryVertices);
<                 if (µ != 0) {
<                         smoothScaled(µ, excludeBoundaryVertices);
<                 }
< 
<                 return displacement;
<         }
< 
<         /**
<          * Performs one pass of scaled laplacian smoothing on the mesh.
<          * 
<          * <p>
<          * This smoothing affects vertices <i>simultaneously</i> (i.e. the displacement
<          * is first computed for every vertex against the original coordinates, and
<          * finally applied to every vertex at the end of the iteration).
<          * 
<          * @param scale                   A scalar parameter that controls the diffusion
<          *                                speed.
<          * @param excludeBoundaryVertices A boolean value indicating whether or not to
<          *                                exclude the boundary vertices from being
<          *                                smoothed, preserving their original location
<          *                                and the area of the mesh.
<          * @return the displacement distance of the most displaced vertex
<          */
<         private float smoothScaled(final double scale, final boolean excludeBoundaryVertices) {
<                 // Use an array instead of ArrayList for displacements
<                 final PVector[] displacements = new PVector[meshVerticesList.length];
< 
<                 float maxDisplacement = 0;
<                 final float s = (float) scale;
< 
<                 for (int i = 0; i < meshVerticesList.length; i++) {
<                         final PMeshVertex mv = meshVerticesList[i];
<                         final PVector laplacian = new PVector();
<                         displacements[i] = laplacian;
< 
<                         if (excludeBoundaryVertices && mv.onBoundary) {
<                                 continue;
<                         }
< 
<                         for (PMeshVertex n : mv.neighbors) {
<                                 PVector neighbor = n.smoothedVertex;
<                                 laplacian.add(neighbor);
<                         }
<                         laplacian.mult(s / mv.neighbors.size());
<                         laplacian.add(PVector.mult(mv.smoothedVertex, -s));
< 
<                         float displacementSq = laplacian.mag();
<                         maxDisplacement = Math.max(displacementSq, maxDisplacement);
<                 }
< 
<                 for (int j = 0; j < meshVerticesList.length; j++) {
<                         PMeshVertex mv = meshVerticesList[j];
<                         mv.smoothedVertex.add(displacements[j]);
<                 }
< 
<                 return (float) maxDisplacement;
<         }
< 
<         private float smoothCotanWeighted(final boolean excludeBoundaryVertices) { // NOTE working?
<                 // https://rodolphe-vaillant.fr/entry/69/c-code-for-cotangent-weights-over-a-triangular-mesh
<         
<                 final double eps = 1e-6f;
<                 final double cotan_max = FastMath.cos(eps) / FastMath.sin(eps);
<         
<                 for (PMeshVertex mv : meshVertices.values()) {
<                         if (excludeBoundaryVertices && mv.onBoundary) {
<                                 continue;
<                         }
<                         final PVector i = mv.smoothedVertex;
<                         final PVector mean = new PVector(0, 0);
<                         double totalWeight = 0;
<         
<                         for (int k = 0; k < mv.neighbors.size(); k++) {
<                                 PVector v_prev = mv.neighbors.get(k == 0 ? mv.neighbors.size() - 1 : k - 1).smoothedVertex;
<                                 PVector v = mv.neighbors.get(k).smoothedVertex;
<                                 PVector v_next = mv.neighbors.get((k + 1) % mv.neighbors.size()).smoothedVertex;
<         
<                                 // Calculate cotangent weights
<                                 PVector v1 = PVector.sub(i, v_prev);
<                                 PVector v2 = PVector.sub(v, v_prev);
<                                 PVector v3 = PVector.sub(i, v_next);
<                                 PVector v4 = PVector.sub(v, v_next);
<         
<                                 double cotan_alpha = cotan(v1, v2);
<                                 double cotan_beta = cotan(v3, v4);
<         
<                                 double weight = (cotan_alpha + cotan_beta);
<         
<                                 if (Double.isNaN(weight)) {
<                                         weight = 0;
<                                 }
<                                 /*
<                                  * Compute the cotangent value close to 0.0f and PI. As cotan approaches
<                                  * infinity close to those values, we clamp.
<                                  */
<                                 weight = clamp(weight, -cotan_max, cotan_max);
<                                 mean.add(PVector.mult(v, (float) weight));
<                                 totalWeight += weight;
<         
<                         }
<                         mean.div((float) totalWeight);
<                         mv.smoothedVertex.set(mean);
<         
<                 }
<         
<                 return 0;
<         }
< 
<         private static float cotan(final PVector a, final PVector b) {
<                 return PVector.dot(a, b) / PVector.cross(a, b, null).normalize().mag();
<         }
< 
<         private static double clamp(double value, double min, double max) {
<                 return Math.max(min, Math.min(value, max));
<         }
< 
<         /**
<          * Smoothes the mesh until the maximum displacement between the original and
<          * smoothed vertices is less than or equal to the specified threshold value.
<          * 
<          * @param preservePerimeter a boolean value indicating whether or not to
<          *                          preserve the perimeter of the mesh during smoothing
<          * @param maxDisplacement   the maximum allowable average displacement between
<          *                          the original and smoothed vertices.
<          */
<         int relax(final boolean preservePerimeter, double minDisplacement) {
<                 minDisplacement = Double.max(minDisplacement, 1e-9);
<                 int relaxations = 0;
<                 double displacement = Double.MAX_VALUE;
< 
<                 do {
<                         displacement = smooth(preservePerimeter);
<                         relaxations++;
<                 } while (displacement > minDisplacement);
< 
<                 return relaxations;
<         }
< 
<         /**
<          * 
<          * Returns a PShape object representing the smoothed mesh, with vertices moved
<          * to their smoothed positions.
<          * 
<          * @return a PShape object representing the smoothed mesh
<          */
<         public PShape getMesh() {
<                 PShape out = new PShape(PConstants.GROUP);
<                 PGS_Conversion.getChildren(mesh).forEach(f -> {
<                         PShape shape = PGS_Conversion.copy(f);
<                         for (int i = 0; i < f.getVertexCount(); i++) {
<                                 shape.setVertex(i, meshVertices.get(shape.getVertex(i)).smoothedVertex);
<                         }
<                         out.addChild(shape);
<                 });
<                 return out;
<         }
---
>     // Other methods remain unchanged...
379c122
<                         originalVertex = v; // same reference
---
>             originalVertex = v;
