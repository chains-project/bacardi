```java
package micycle.pgs;

import static micycle.pgs.PGS.GEOM_FACTORY;
import static micycle.pgs.PGS_Conversion.fromPShape;
import static micycle.pgs.PGS_Conversion.toPShape;

import java.awt.geom.Rectangle2D;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.SplittableRandom;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import org.apache.commons.math3.ml.clustering.CentroidCluster;
import org.apache.commons.math3.ml.clustering.Clusterable;
import org.apache.commons.math3.ml.clustering.KMeansPlusPlusClusterer;
import org.apache.commons.math3.ml.distance.EuclideanDistance;
import org.locationtech.jts.algorithm.Angle;
import org.locationtech.jts.algorithm.Area;
import org.locationtech.jts.algorithm.Orientation;
import org.locationtech.jts.algorithm.hull.ConcaveHullOfPolygons;
import org.locationtech.jts.algorithm.locate.IndexedPointInAreaLocator;
import org.locationtech.jts.densify.Densifier;
import org.locationtech.jts.dissolve.LineDissolver;
import org.locationtech.jts.geom.Coordinate;
import org.locationtech.jts.geom.Envelope;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.GeometryFactory;
import org.locationtech.jts.geom.LineSegment;
import org.locationtech.jts.geom.LineString;
import org.locationtech.jts.geom.LinearRing;
import org.locationtech.jts.geom.Location;
import org.locationtech.jts.geom.Polygon;
import org.locationtech.jts.geom.Polygonal;
import org.locationtech.jts.geom.prep.PreparedGeometry;
import org.locationtech.jts.geom.prep.PreparedGeometryFactory;
import org.locationtech.jts.geom.util.GeometryFixer;
import org.locationtech.jts.geom.util.LineStringExtracter;
import org.locationtech.jts.geom.util.PolygonExtracter;
import org.locationtech.jts.linearref.LengthIndexedLine;
import org.locationtech.jts.noding.MCIndexSegmentSetMutualIntersector;
import org.locationtech.jts.noding.NodedSegmentString;
import org.locationtech.jts.noding.Noder;
import org.locationtech.jts.noding.SegmentIntersectionDetector;
import org.locationtech.jts.noding.SegmentIntersector;
import org.locationtech.jts.noding.SegmentString;
import org.locationtech.jts.noding.SegmentStringUtil;
import org.locationtech.jts.noding.snap.SnappingNoder;
import org.locationtech.jts.operation.overlay.snap.GeometrySnapper;
import org.locationtech.jts.operation.overlayng.MultiOperationOverlayNG;
import org.locationtech.jts.operation.overlayng.OverlayNG;
import org.locationtech.jts.operation.polygonize.Polygonizer;
import org.locationtech.jts.operation.union.UnaryUnionOp;
import org.locationtech.jts.shape.random.RandomPointsInGridBuilder;
import org.tinfour.common.IConstraint;
import org.tinfour.common.IIncrementalTin;
import org.tinfour.common.PolygonConstraint;
import org.tinfour.common.SimpleTriangle;
import org.tinfour.common.Vertex;
import org.tinfour.utils.TriangleCollector;
import org.tinfour.voronoi.BoundedVoronoiBuildOptions;
import org.tinfour.voronoi.BoundedVoronoiDiagram;

import com.vividsolutions.jcs.conflate.coverage.CoverageCleaner;
import com.vividsolutions.jcs.conflate.coverage.CoverageCleaner.Parameters;
import com.vividsolutions.jump.feature.FeatureCollection;
import com.vividsolutions.jump.feature.FeatureDatasetFactory;
import com.vividsolutions.jump.feature.FeatureUtil;
import com.vividsolutions.jump.task.DummyTaskMonitor;

import it.unimi.dsi.util.XoRoShiRo128PlusRandom;
import it.unimi.dsi.util.XoRoShiRo128PlusRandomGenerator;
import micycle.balaban.BalabanSolver;
import micycle.balaban.Point;
import micycle.balaban.Segment;
import micycle.pgs.color.Colors;
import micycle.pgs.color.ColorUtils;
import micycle.pgs.commons.PolygonDecomposition;
import micycle.pgs.commons.SeededRandomPointsInGridBuilder;
import micycle.trapmap.TrapMap;
import processing.core.PConstants;
import processing.core.PShape;
import processing.core.PVector;

/**
 * Geometry Processing -- methods that process a shape in some way: compute
 * hulls, partition, slice, etc.
 * 
 */
public final class PGS_Processing {

    private PGS_Processing() {
    }

    // Other methods...

    /**
     * Generates N random points that lie within the shape region.
     * <p>
     * This is a fast method but note that the underlying algorithm makes a minor
     * trade-off for its speed: the resulting point set is slightly more uniformly
     * distributed over the input shape compared to a purely random approach (this
     * arises because the shape is first divided into triangles; each triangle is
     * then sampled a <b>fixed</b> number of times according to its area relative to
     * the whole).
     * 
     * @param shape  defines the region in which random points are generated
     * @param points number of points to generate within the shape region
     * @return
     * @see #generateRandomPoints(PShape, int, long)
     */
    public static List<PVector> generateRandomPoints(PShape shape, int points) {
        return generateRandomPoints(shape, points, System.nanoTime());
    }

    /**
     * Generates N random points that are contained within the shape region. Points
     * are distributed completely randomly. This method accepts a seed for the RNG
     * when identical sequences of random points are required.
     * <p>
     * This is a fast method but note that the underlying algorithm makes a minor
     * trade-off for its speed: the resulting point set is slightly more uniformly
     * distributed over the input shape compared to a purely random approach (this
     * arises because the shape is first divided into triangles; each triangle is
     * then sampled a <b>fixed</b> number of times according to its area relative to
     * the whole).
     * 
     * @param shape  defines the region in which random points are generated
     * @param points number of points to generate within the shape region
     * @param seed   number used to initialize the underlying pseudorandom number
     *               generator
     * @return
     * @since 1.1.0
     * @see #generateRandomPoints(PShape, int)
     * @see #generateRandomGridPoints(PShape, int, boolean, double)
     */
    public static List<PVector> generateRandomPoints(PShape shape, int points, long seed) {
        final ArrayList<PVector> randomPoints = new ArrayList<>(points); // random points out

        // Updated method call to use the correct method signature
        final IIncrementalTin tin = PGS_Triangulation.createDelaunayTriangulation(shape); 
        final boolean constrained = !tin.getConstraints().isEmpty();
        final double totalArea = StreamSupport.stream(tin.getConstraints().spliterator(), false)
                .mapToDouble(c -> ((PolygonConstraint) c).getArea()).sum();

        // use arrays to hold variables (to enable assignment during consumer)
        final SimpleTriangle[] largestTriangle = new SimpleTriangle[1];
        final double[] largestArea = new double[1];

        final SplittableRandom r = new SplittableRandom(seed);
        TriangleCollector.visitSimpleTriangles(tin, triangle -> {
            final IConstraint constraint = triangle.getContainingRegion();
            if (!constrained || (constraint != null && constraint.definesConstrainedRegion())) {
                final Vertex a = triangle.getVertexA();
                final Vertex b = triangle.getVertexB();
                final Vertex c = triangle.getVertexC();

                // TODO more robust area (dense input produces slivers)
                final double triangleArea = 0.5 * ((b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y));
                if (triangleArea > largestArea[0]) {
                    largestTriangle[0] = triangle;
                    largestArea[0] = triangleArea;
                }

                /*
                 * Rather than choose a random triangle for each sample, pre-determine the
                 * number of samples per triangle and sample this number of points in each
                 * triangle successively. I conjecture that this results in a slightly more
                 * uniform random distribution, the downside of which is the resulting
                 * distribution has less entropy.
                 */
                double areaWeight = (triangleArea / totalArea) * points;
                int samples = (int) Math.round(areaWeight);
                if (r.nextDouble() <= (areaWeight - samples)) {
                    samples += 1;
                }
                for (int i = 0; i < samples; i++) {
                    final double s = r.nextDouble();
                    final double t = Math.sqrt(r.nextDouble());
                    final double rX = (1 - t) * a.x + t * ((1 - s) * b.x + s * c.x);
                    final double rY = (1 - t) * a.y + t * ((1 - s) * b.y + s * c.y);
                    randomPoints.add(new PVector((float) rX, (float) rY));
                }
            }
        });

        final int remaining = points - randomPoints.size(); // due to rounding, may be a few above/below target number
        if (remaining > 0) {
            final Vertex a = largestTriangle[0].getVertexA();
            final Vertex b = largestTriangle[0].getVertexB();
            final Vertex c = largestTriangle[0].getVertexC();
            for (int i = 0; i < remaining; i++) {
                double s = r.nextDouble();
                double t = Math.sqrt(r.nextDouble());
                double rX = (1 - t) * a.x + t * ((1 - s) * b.x + s * c.x);
                double rY = (1 - t) * a.y + t * ((1 - s) * b.y + s * c.y);
                randomPoints.add(new PVector((float) rX, (float) rY));
            }
        } else if (remaining < 0) {
            Collections.shuffle(randomPoints, new XoRoShiRo128PlusRandom(seed)); // shuffle so that points are removed from regions randomly
            return randomPoints.subList(0, points);
        }

        return randomPoints;
    }

    // Other methods...

}
```
