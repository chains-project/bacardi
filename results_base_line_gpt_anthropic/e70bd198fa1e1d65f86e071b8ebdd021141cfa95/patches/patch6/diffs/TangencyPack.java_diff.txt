48,54d47
<         /*-
<          * Good explanation of this algorithm here:
<          *              http://www.ams.org/publicoutreach/feature-column/fc-2015-12
<          * Thorough (yet ugly) implementation here (by Stephenson):
<          *              https://github.com/kensmath/CirclePack/blob/CP-develop/src/rePack/EuclPacker.java
<          */
< 
59,62d51
<         /**
<          * Maps a vertex to a list of it neighbouring vertices; the neighbour list is
<          * ordered radially around the given vertex.
<          */
64,66d52
<         /**
<          * The radius of each circle (including boundary circles).
<          */
166d151
<                 // pick a rather central vertex, so output is same on identical input
178,201d162
<         /**
<          * Find radii of circles using numerical relaxation. Circle radii converge
<          * rapidly to a unique fixed point for which all flower angles are are within a
<          * desired tolerance of 2π, at which point iteration stops and a packing is
<          * found.
<          * 
<          * @deprecated in favor of superstep solution
<          */
<         @Deprecated
<         private void computeRadiiSimple() {
<                 double lastChange = TOLERANCE + 1;
<                 while (lastChange > TOLERANCE) {
<                         lastChange = 1.0;
<                         for (Vertex v : flowers.keySet()) {
<                                 double theta = flower(v);
<                                 lastChange = Math.max(lastChange, theta);
<                         }
<                 }
<         }
< 
<         /**
<          * This method implements the super acceleration described in 'A circle packing
<          * algorithm'.
<          */
204c165
<                 int key = 1; // initial superstep type
---
>                 int key = 1; 
208c169
<                 while ((accumErr2 > ttoler && localPasses < 1000)) { // main loop
---
>                 while ((accumErr2 > ttoler && localPasses < 1000)) { 
214c175
<                         do { // Make sure factor < 1.0
---
>                         do {
225,226d185
<                         // ================= superstep calculation ====================
< 
229d187
<                         // find maximum step one can safely take
239c197
<                                         lmax = (lmax < (tr = (-r2 / rat))) ? lmax : tr; // to keep R>0
---
>                                         lmax = (lmax < (tr = (-r2 / rat))) ? lmax : tr; 
244d201
<                         // do super step
249c206
<                         if (key == 1) { // type 1 SS
---
>                         if (key == 1) { 
251c208
<                                 double mmax = 0.75 / (1 - factor); // upper limit on m
---
>                                 double mmax = 0.75 / (1 - factor); 
254c211
<                         } else { // type 2 SS
---
>                         } else { 
257c214
<                                 if (sct > fct && Math.abs(factor - fact0) < ftol) { // try SS-2
---
>                                 if (sct > fct && Math.abs(factor - fact0) < ftol) { 
261c218
<                                         lambda = factor; // do something
---
>                                         lambda = factor; 
266d222
<                         // interpolate new radii labels
274,276d229
<                         // end of superstep
< 
<                         // do step/check superstep
280,284c233,236
<                         // check results
<                         double pred = FastMath.exp(lambda * FastMath.log(factor)); // predicted improvement
<                         double act = accumErr2 / c1; // actual improvement
<                         if (act < 1) { // did some good
<                                 if (act > pred) { // not as good as expected: reset
---
>                         double pred = FastMath.exp(lambda * FastMath.log(factor)); 
>                         double act = accumErr2 / c1; 
>                         if (act < 1) { 
>                                 if (act > pred) { 
288,289c240,241
<                                 } // implied else: accept result
<                         } else { // reset to before superstep
---
>                                 } 
>                         } else { 
304,308d255
<         /**
<          * Determine the centers of the circles using radii of the interior circles.
<          * 
<          * @return
<          */
313,314c260,261
<                         Vertex k1 = centralVertex; // pick one internal circle
<                         placements.put(k1, new Complex(0, 0)); // place it at the origin
---
>                         Vertex k1 = centralVertex; 
>                         placements.put(k1, new Complex(0, 0)); 
316,318c263,265
<                         Vertex k2 = flowers.get(k1).get(0); // pick one of its neighbors
<                         placements.put(k2, new Complex(radii.getDouble(k1) + radii.getDouble(k2))); // place it on the real axis
<                         place(k1); // recursively place the rest
---
>                         Vertex k2 = flowers.get(k1).get(0); 
>                         placements.put(k2, new Complex(radii.getDouble(k1) + radii.getDouble(k2))); 
>                         place(k1); 
327,331d273
<         /**
<          * Compute the angle sum for every flower.
<          * 
<          * @return sum of angle error (difference between 2PI) across all flowers
<          */
346,349d287
<                         // alternative form
< //                      double hat = ra / (1.0 / FastMath.sin(angleSum / (2 * flower.size())) - 1);
< //                      double r2 = hat * (1.0 / FastMath.sin(Math.PI / flower.size()) - 1);
< 
352c290
<                         error += angleSum * angleSum; // accum abs error
---
>                         error += angleSum * angleSum; 
357,363d294
<         /**
<          * 
<          * @param rc     radius of center circle
<          * @param center center circle
<          * @param flower center circle's petals
<          * @return
<          */
374,382d304
<         /**
<          * Compute the angle sum for the petals surrounding the given vertex and update
<          * the radius of the vertex such that the angle sum would equal 2π.
<          * 
<          * @param center target vertex
<          * @return a measure of the error (difference between target angle sum (2π) and
<          *         the actual angle sum
<          * @deprecated used by {@link #computeRadiiSimple()}
<          */
400,402d321
<         /**
<          * Recursively determine centers of all circles surrounding a given vertex.
<          */
404d322
< 
406c324
<                         return; // boundary vertex
---
>                         return; 
436,440d353
<                 /*
<                  * Overall computation time is actually reduced by foregoing trig approximation
<                  * functions (such as tangentAngleFast()), because the slight inaccuracies cause
<                  * solution to converge more slowly, performing more iterations overall.
<                  */
446,455d358
<         /**
<          * Computes the angle that circles y and z make with circle x (angle yxz). The
<          * circles are given by their radii and are mutually tangent.
<          * 
<          * @param rx radius of circle x, the circle of interest
<          * @param ry radius of circle y, a "petal" circle
<          * @param rz radius of circle z, a "petal" circle
<          * @return angle of yxz
<          * @deprecated
<          */
457,459d359
<                 final double x = (ry * rz) / ((rx + ry) * (rx + rz));
<                 // return 2 * Fixed64.ToDouble(Fixed64.Asin(Fixed64.FromDouble(Math.sqrt(x))));
<                 // return 2 * Fixed64.ToDouble(Fixed64.Atan(Fixed64.FromDouble(Math.sqrt(x) / (Math.sqrt(1 - x)))));
476,485d375
<                 /**
<                  * Given two points p and q compare them with respect to their radial ordering
<                  * about point o. First checks radial ordering.
<                  *
<                  * @param o the origin
<                  * @param p a point
<                  * @param q another point
<                  * @return -1, 0 or 1 depending on whether angle p is less than, equal to or
<                  *         greater than angle q
<                  */
