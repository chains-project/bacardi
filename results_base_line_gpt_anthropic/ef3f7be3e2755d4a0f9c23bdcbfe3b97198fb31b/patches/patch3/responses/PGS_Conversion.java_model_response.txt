```java
package micycle.pgs;

import static micycle.pgs.PGS.GEOM_FACTORY;
import static micycle.pgs.PGS.coordFromPVector;
import static micycle.pgs.color.ColorUtils.decomposeclrRGB;
import static processing.core.PConstants.BEZIER_VERTEX;
import static processing.core.PConstants.CURVE_VERTEX;
import static processing.core.PConstants.GROUP;
import static processing.core.PConstants.QUADRATIC_VERTEX;

import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.PathIterator;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.commons.io.FileUtils;
import org.jgrapht.alg.drawing.IndexedFRLayoutAlgorithm2D;
import org.jgrapht.alg.drawing.LayoutAlgorithm2D;
import org.jgrapht.alg.drawing.model.Box2D;
import org.jgrapht.alg.drawing.model.LayoutModel2D;
import org.jgrapht.alg.drawing.model.MapLayoutModel2D;
import org.jgrapht.alg.drawing.model.Point2D;
import org.jgrapht.alg.util.NeighborCache;
import org.jgrapht.graph.DefaultEdge;
import org.jgrapht.graph.SimpleGraph;
import org.jgrapht.graph.SimpleWeightedGraph;
import org.locationtech.jts.algorithm.Orientation;
import org.locationtech.jts.awt.ShapeReader;
import org.locationtech.jts.awt.ShapeWriter;
import org.locationtech.jts.geom.Coordinate;
import org.locationtech.jts.geom.CoordinateList;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.LineString;
import org.locationtech.jts.geom.LinearRing;
import org.locationtech.jts.geom.Polygon;
import org.locationtech.jts.geom.PrecisionModel;
import org.locationtech.jts.geom.util.AffineTransformation;
import org.locationtech.jts.io.ParseException;
import org.locationtech.jts.io.WKBReader;
import org.locationtech.jts.io.WKBWriter;
import org.locationtech.jts.io.WKTReader;
import org.locationtech.jts.io.WKTWriter;
import org.locationtech.jts.io.geojson.GeoJsonReader;
import org.locationtech.jts.io.geojson.GeoJsonWriter;
import org.locationtech.jts.util.GeometricShapeFactory;
import org.scoutant.polyline.PolylineDecoder;

import it.rambow.master.javautils.PolylineEncoder;
import it.rambow.master.javautils.Track;
import it.rambow.master.javautils.Trackpoint;
import it.unimi.dsi.util.XoRoShiRo128PlusRandom;
import micycle.betterbeziers.CubicBezier;
import micycle.pgs.color.Colors;
import micycle.pgs.commons.Nullable;
import micycle.pgs.commons.PEdge;
import processing.core.PConstants;
import processing.core.PMatrix;
import processing.core.PShape;
import processing.core.PVector;

/**
 * Facilitates conversion between <i>Processing's</i> {@code PShapes} and
 * <i>JTS's</i> {@code Geometries}, along with various other formats. It also
 * offers additional utility methods to assist with handling {@code PShapes}.
 * <p>
 * Though certain conversion methods are utilised internally by the library,
 * they have been kept public to cater to more complex user requirements.
 * <p>
 * Note: JTS {@code Geometries} do not provide support for bezier curves. As
 * such, bezier curves are linearised/divided into straight line segments during
 * the conversion process from {@code PShape} to JTS {@code Geometry}.
 * <p>
 * Two configurable boolean flags influence the conversion process:
 * {@link #PRESERVE_STYLE} (set to true by default), and
 * {@link #HANDLE_MULTICONTOUR} (set to false by default). Users are encouraged
 * to review these flags as part of more complicated workflows with this class.
 * 
 * @author Michael Carleton
 */
public final class PGS_Conversion {

	/** Approximate distance between successive sample points on bezier curves */
	static final float BEZIER_SAMPLE_DISTANCE = 2;
	private static Field MATRIX_FIELD;
	/**
	 * A boolean flag that affects whether a PShape's style (fillColor, strokeColor,
	 * strokeWidth) is preserved during <code>PShape->Geometry->PShape</code>
	 * conversion (i.e. when <code>toPShape(fromPShape(myPShape))</code> is called).
	 * Default = <code>true</code>.
	 */
	public static boolean PRESERVE_STYLE = true;
	/**
	 * A boolean flag that, when true, enables a specialised subroutine during the
	 * {@link #fromPShape(PShape) fromPShape()} conversion to correctly convert
	 * <b>single</b> PShapes comprised of multiple contours, each representing a
	 * separate shape. If set to <code>false</code>, the {@link #fromPShape(PShape)
	 * fromPShape()} method assumes that in multi-contour shapes, every contour
	 * beyond the first represents a hole, which is generally an adequate
	 * assumption.
	 * <p>
	 * This feature is disabled by default because it necessitates additional
	 * computation, such as determining polygon ring orientations, and is seldom
	 * required (unless one is dealing with fonts, I have observed). Default =
	 * <code>false</code>.
	 * <p>
	 * For more information, refer to the discussion on this topic at
	 * <a href="https://github.com/micycle1/PGS/issues/67">GitHub</a>.
	 */
	public static boolean HANDLE_MULTICONTOUR = false;

	static {
		try {
			MATRIX_FIELD = PShape.class.getDeclaredField("matrix");
			MATRIX_FIELD.setAccessible(true);
		} catch (NoSuchFieldException e) {
			System.err.println(e.getLocalizedMessage());
		}
	}

	private PGS_Conversion() {
	}

	/**
	 * Converts a JTS Geometry into a corresponding PShape. In the case of
	 * MultiGeometries (which include collections of geometries), the result is a
	 * GROUP PShape containing the appropriate child PShapes.
	 * <p>
	 * The conversion process follows the geometry types supported by JTS, namely:
	 * <ul>
	 * <li>{@link Geometry#TYPENAME_GEOMETRYCOLLECTION GEOMETRYCOLLECTION}:
	 * Converted to a GROUP PShape if it contains multiple geometries. For single
	 * geometry collections, it extracts and converts the single geometry.</li>
	 * <li>{@link Geometry#TYPENAME_MULTIPOLYGON MULTIPOLYGON}: Similar to
	 * GeometryCollection, MultiPolygons are converted to a GROUP PShape, with each
	 * polygon converted to a child PShape.</li>
	 * <li>{@link Geometry#TYPENAME_MULTILINESTRING MULTILINESTRING}:
	 * MultiLineStrings are handled in the same way as GeometryCollections and
	 * MultiPolygons, converted to a GROUP PShape containing child PShapes.</li>
	 * <li>{@link Geometry#TYPENAME_LINEARRING LINEARRING} and
	 * {@link Geometry#TYPENAME_LINESTRING LINESTRING}: These are converted to a
	 * PATH PShape, preserving the closed or open nature of the original
	 * LineString.</li>
	 * <li>{@link Geometry#TYPENAME_POLYGON POLYGON}: Converted to a PATH PShape,
	 * with each contour of the polygon represented as a series of vertices in the
	 * PShape. Inner contours, or 'holes' in the polygon, are handled
	 * separately.</li>
	 * <li>{@link Geometry#TYPENAME_POINT POINT} and
	 * {@link Geometry#TYPENAME_MULTIPOINT MULTIPOINT}: These are converted to a
	 * GEOMETRY PShape with each point represented as a vertex.</li>
	 * </ul>
	 * <p>
	 * Please note that any unsupported geometry types will result in an error
	 * message.
	 * <p>
	 * If {@link #PRESERVE_STYLE} is enabled and the geometry includes user data in
	 * the form of PShapeData, the style from the data is applied to the resulting
	 * PShape.
	 * 
	 * @param g The JTS geometry to convert.
	 * @return A PShape that represents the input geometry, or a new, empty PShape
	 *         if the input is null.
	 */
	public static PShape toPShape(final Geometry g) {
		if (g == null) {
			return new PShape();
		}
		PShape shape = new PShape();
		// apply PGS style by default
		shape.setFill(true);
		shape.setFill(micycle.pgs.color.Colors.WHITE);
		shape.setStroke(true);
		shape.setStroke(micycle.pgs.color.Colors.PINK);
		shape.setStrokeWeight(4);
		shape.setStrokeJoin(PConstants.ROUND);
		shape.setStrokeCap(PConstants.ROUND);

		switch (g.getGeometryType()) {
			case Geometry.TYPENAME_GEOMETRYCOLLECTION :
			case Geometry.TYPENAME_MULTIPOLYGON :
			case Geometry.TYPENAME_MULTILINESTRING :
				if (g.getNumGeometries() == 1) {
					shape = toPShape(g.getGeometryN(0));
				} else {
					shape.setFamily(GROUP);
					for (int i = 0; i < g.getNumGeometries(); i++) {
						shape.addChild(toPShape(g.getGeometryN(i)));
					}
				}
				break;
			// TODO treat closed linestrings as unfilled & unclosed paths?
			case Geometry.TYPENAME_LINEARRING : // LinearRings are closed by definition
			case Geometry.TYPENAME_LINESTRING : // LineStrings may be open
				final LineString l = (LineString) g;
				final boolean closed = l.isClosed();
				shape.setFamily(PShape.PATH);
				shape.beginShape();
				Coordinate[] coords = l.getCoordinates();
				for (int i = 0; i < coords.length - (closed ? 1 : 0); i++) {
					shape.vertex((float) coords[i].x, (float) coords[i].y);
				}
				if (closed) { // closed vertex was skipped, so close the path
					shape.endShape(PConstants.CLOSE);
				} else {
					// shape is more akin to an unconnected line: keep as PATH shape, but don't fill
					// visually
					shape.endShape();
					shape.setFill(false);
				}
				break;
			case Geometry.TYPENAME_POLYGON :
				final Polygon polygon = (Polygon) g;
				shape.setFamily(PShape.PATH);
				shape.beginShape();

				/*
				 * Outer and inner loops are iterated up to length-1 to skip the point that
				 * closes the JTS shape (same as the first point).
				 */
				coords = polygon.getExteriorRing().getCoordinates();
				for (int i = 0; i < coords.length - 1; i++) {
					final Coordinate coord = coords[i];
					shape.vertex((float) coord.x, (float) coord.y);
				}

				for (int j = 0; j < polygon.getNumInteriorRing(); j++) { // holes
					shape.beginContour();
					coords = polygon.getInteriorRingN(j).getCoordinates();
					for (int i = 0; i < coords.length - 1; i++) {
						final Coordinate coord = coords[i];
						shape.vertex((float) coord.x, (float) coord.y);
					}
					shape.endContour();
				}
				shape.endShape(PConstants.CLOSE);
				break;
			case Geometry.TYPENAME_POINT :
			case Geometry.TYPENAME_MULTIPOINT :
				coords = g.getCoordinates();
				shape.setFamily(PShape.GEOMETRY);
				shape.setFill(false);
				shape.setStrokeCap(PConstants.ROUND);
				shape.beginShape(PConstants.POINTS);
				for (final Coordinate coord : coords) {
					shape.vertex((float) coord.x, (float) coord.y);
				}
				shape.endShape();
				break;
			default :
				System.err.println("PGS_Conversion Error: " + g.getGeometryType() + " geometry types are unsupported.");
				break;
		}

		if (PRESERVE_STYLE && g.getUserData() != null && g.getUserData() instanceof PShapeData) {
			PShapeData style = (PShapeData) g.getUserData();
			style.applyTo(shape);
		}

		return shape;
	}

	/**
	 * 
	 * Converts a collection of JTS Geometries into a corresponding GROUP PShape.
	 * This method loops through the provided geometries, converting each individual
	 * geometry into a PShape, and then adds it as a child to the GROUP PShape.
	 * <p>
	 * In case the collection only contains a single geometry, this method will
	 * instead return a PShape that directly corresponds to that single geometry. It
	 * will not be wrapped in a GROUP shape in this case.
	 * 
	 * @param geometries A collection of JTS Geometries to convert into a PShape.
	 * @return A PShape that represents the collection of input geometries. If the
	 *         collection contains only a single geometry, the return is a PShape
	 *         directly equivalent to that geometry. Otherwise, the return is a
	 *         GROUP PShape containing child PShapes for each geometry in the
	 *         collection.
	 */
	public static PShape toPShape(Collection<? extends Geometry> geometries) {
		PShape shape = new PShape(GROUP);
		shape.setFill(true);
		shape.setFill(micycle.pgs.color.Colors.WHITE);
		shape.setStroke(true);
		shape.setStroke(micycle.pgs.color.Colors.PINK);
		shape.setStrokeWeight(4);

		for (Geometry g : geometries) {
			shape.addChild(toPShape(g)); // Updated to ensure each Geometry is correctly processed
		}
		if (shape.getChildCount() == 1) {
			return shape.getChild(0);
		}

		return shape;
	}

	// ... (rest of the class remains unchanged)
}
``` 

### Changes Made:
1. **Fixed the `toPShape(Collection<? extends Geometry> geometries)` method**: Instead of using `geometries.forEach(g -> shape.addChild(toPShape(g)));`, I replaced it with a traditional for-each loop to clarify the processing of each `Geometry`. This change was made to ensure type safety and to directly address the error regarding incompatible bounds.
2. **Overall Structure**: The rest of the methods and class structure remain unchanged, ensuring the integrity of other functionalities. 

This should resolve the compilation issue stemming from the updated dependency, while maintaining the intended functionality.
